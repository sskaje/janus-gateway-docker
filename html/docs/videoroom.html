<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VideoRoom plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.9.2/umd/popper.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.2/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.2/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 2001;" src="forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<div class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary">
<div class="container">
	<a class="navbar-brand" href="/">Janus (multistream)</a>
	<button type="button" class="navbar-toggler" data-toggle="collapse" data-target=".navbar-collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="navbar-collapse collapse" id="navbarResponsive">
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="/demos/">Demos</a></li>
			<li class="nav-item"><a class="nav-link active" href="index.html">Documentation</a></li>
			<li class="nav-item"><a class="nav-link" href="/citeus.html">Papers</a></li>
			<li class="nav-item"><a class="nav-link" href="/support.html">Need help?</a></li>
			<li class="nav-item"><a class="nav-link" href="https://janus-legacy.conf.meetecho.com/">Janus (0.x)</a></li>
			<li class="nav-item"><a class="nav-link januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<ul class="navbar-nav ms-auto">
			<li class="nav-item">
				<a class="nav-link meetecho-logo" target="_blank" href="https://www.meetecho.com">
					<img src="meetecho-logo.png"/>
				</a>
			</li>
		</ul>
	</div>
</div>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">VideoRoom plugin documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a plugin implementing a videoconferencing SFU (Selective Forwarding Unit) for Janus, that is an audio/video router. This means that the plugin implements a virtual conferencing room peers can join and leave at any time. This room is based on a Publish/Subscribe pattern. Each peer can publish his/her own live audio/video feeds: this feed becomes an available stream in the room the other participants can subscribe to. This means that this plugin allows the realization of several different scenarios, ranging from a simple webinar (one speaker, several watchers) to a fully meshed video conference (each peer sending and receiving to and from all the others).</p>
<p>Notice that, since Janus now supports multistream PeerConnections, subscriptions can be done either in "bulks" (you use a single PeerConnection to subscribe to multiple streams from one or more publishers) or separately (each PeerConnections represents a subscription to a single publisher). Same thing for publishers: you may choose to publish, e.g., audio and video on one PeerConnection, and share your screen on another, or publish everything on the same PeerConnection instead. While functionally both approaches (multistream vs. legacy mode) are the same (the same media flows in both cases), the differences are in how resources are used, and in how the client has to handle incoming and outgoing connections. Besides, one approach might make more sense in some scenarios, and the other make more sense in different use cases. As such, the approach to follow is left to the developer and the application.</p>
<p>What is important to point out, though, is that publishers and subscribers will in all cases require different PeerConnections. This means that, even with multistream, you won't be able to use a single PeerConnection to send your contributions and receive those from everyone else. This is a choice done by design, to avoid the issues that would inevitably arise when doing, for instance, renegotiations to update the streams.</p>
<p>On a more general note and to give some more context with respect to the core functionality in Janus, notice that, considering this plugin allows for several different WebRTC PeerConnections to be on at the same time for the same peer (different publishers and subscribers for sure, and potentially more than one of each if multistream is not in use), each peer will often need to attach several times to the same plugin for each stream: this means that each peer needs to have at least one handle active for managing its relation with the plugin (joining a room, leaving a room, muting/unmuting, publishing, receiving events), and needs to open others when they want to subscribe to a feed from other participants (the number depends on the subscription approach of choice). Handles used for subscriptions, though, would be logically "subjects" to the master one used for managing the room: this means that they cannot be used, for instance, to unmute in the room, as their only purpose would be to provide a context in which creating the recvonly PeerConnections for the subscription(s).</p>
<p>Rooms to make available are listed in the plugin configuration file. A pre-filled configuration file is provided in <code>conf/janus.plugin.videoroom.jcfg</code> and includes a demo room for testing. The same plugin is also used dynamically (that is, with rooms created on the fly via API) in the Screen Sharing demo as well.</p>
<p>To add more rooms or modify the existing one, you can use the following syntax:</p>
<pre class="fragment">room-&lt;unique room ID&gt;: {
        description = This is my awesome room
        is_private = true|false (private rooms don't appear when you do a 'list' request, default=false)
        secret = &lt;optional password needed for manipulating (e.g. destroying) the room&gt;
        pin = &lt;optional password needed for joining the room&gt;
        require_pvtid = true|false (whether subscriptions are required to provide a valid private_id
                                 to associate with a publisher, default=false)
        signed_tokens = true|false (whether access to the room requires signed tokens; default=false,
                                 only works if signed tokens are used in the core as well)
        publishers = &lt;max number of concurrent senders&gt; (e.g., 6 for a video
                                 conference or 1 for a webinar, default=3)
        bitrate = &lt;max video bitrate for senders&gt; (e.g., 128000)
        bitrate_cap = &lt;true|false, whether the above cap should act as a limit to dynamic bitrate changes by publishers, default=false&gt;,
        fir_freq = &lt;send a FIR to publishers every fir_freq seconds&gt; (0=disable)
        audiocodec = opus|g722|pcmu|pcma|isac32|isac16 (audio codec to force on publishers, default=opus
                                can be a comma separated list in order of preference, e.g., opus,pcmu)
        videocodec = vp8|vp9|h264|av1|h265 (video codec to force on publishers, default=vp8
                                can be a comma separated list in order of preference, e.g., vp9,vp8,h264)
        vp9_profile = VP9-specific profile to prefer (e.g., "2" for "profile-id=2")
        h264_profile = H.264-specific profile to prefer (e.g., "42e01f" for "profile-level-id=42e01f")
        opus_fec = true|false (whether inband FEC must be negotiated; only works for Opus, default=true)
        opus_dtx = true|false (whether DTX must be negotiated; only works for Opus, default=false)
        audiolevel_ext = true|false (whether the ssrc-audio-level RTP extension must be
                negotiated/used or not for new publishers, default=true)
        audiolevel_event = true|false (whether to emit event to other users or not, default=false)
        audio_active_packets = 100 (number of packets with audio level, default=100, 2 seconds)
        audio_level_average = 25 (average value of audio level, 127=muted, 0='too loud', default=25)
        videoorient_ext = true|false (whether the video-orientation RTP extension must be
                negotiated/used or not for new publishers, default=true)
        playoutdelay_ext = true|false (whether the playout-delay RTP extension must be
                negotiated/used or not for new publishers, default=true)
        transport_wide_cc_ext = true|false (whether the transport wide CC RTP extension must be
                negotiated/used or not for new publishers, default=true)
        record = true|false (whether this room should be recorded, default=false)
        rec_dir = &lt;folder where recordings should be stored, when enabled&gt;
        lock_record = true|false (whether recording can only be started/stopped if the secret
                                is provided, or using the global enable_recording request, default=false)
        notify_joining = true|false (optional, whether to notify all participants when a new
                                participant joins the room. The Videoroom plugin by design only notifies
                                new feeds (publishers), and enabling this may result extra notification
                                traffic. This flag is particularly useful when enabled with require_pvtid
                                for admin to manage listening only participants. default=false)
        require_e2ee = true|false (whether all participants are required to publish and subscribe
                                using end-to-end media encryption, e.g., via Insertable Streams; default=false)
        dummy_publisher = true|false (whether a dummy publisher should be created in this room,
                                with one separate m-line for each codec supported in the room; this is
                                useful when there's a need to create subscriptions with placeholders
                                for some or all m-lines, even when they aren't used yet; default=false)
        dummy_streams = in case dummy_publisher is set to true, array of codecs to offer,
                                optionally with a fmtp attribute to match (codec/fmtp properties).
                                If not provided, all codecs enabled in the room are offered, with no fmtp.
                                Notice that the fmtp is parsed, and only a few codecs are supported.
        threads = number of threads to assist with the relaying of publishers in the room; as
                                in the Streaming plugin, this setting can help if you expect a lot of subscribers
                                that may cause the plugin to slow down and fail to catch up (default=0)
}
</pre><p>Note that recording will work with all codecs except iSAC.</p>
<h1><a class="anchor" id="sfuapi"></a>
Video Room API</h1>
<p>The Video Room API supports several requests, some of which are synchronous and some asynchronous. There are some situations, though, (invalid JSON, invalid request) which will always result in a synchronous error response even for asynchronous requests.</p>
<p><code>create</code> , <code>destroy</code> , <code>edit</code> , <code>exists</code>, <code>list</code>, <code>allowed</code>, <code>kick</code> , <code>moderate</code> , <code>enable_recording</code> , <code>listparticipants</code> and <code>listforwarders</code> are synchronous requests, which means you'll get a response directly within the context of the transaction. <code>create</code> allows you to create a new video room dynamically, as an alternative to using the configuration file; <code>edit</code> allows you to dynamically edit some room properties (e.g., the PIN); <code>destroy</code> removes a video room and destroys it, kicking all the users out as part of the process; <code>exists</code> allows you to check whether a specific video room exists; finally, <code>list</code> lists all the available rooms, while <code>listparticipants</code> lists all the active (as in currently publishing something) participants of a specific room and their details.</p>
<p>The <code>join</code> , <code>joinandconfigure</code> , <code>configure</code> , <code>publish</code> , <code>unpublish</code> , <code>start</code> , <code>pause</code> , <code>switch</code> and <code>leave</code> requests instead are all asynchronous, which means you'll get a notification about their success or failure in an event. <code>join</code> allows you to join a specific video room, specifying whether that specific PeerConnection will be used for publishing or watching; <code>configure</code> can be used to modify some of the participation settings (e.g., bitrate cap); <code>joinandconfigure</code> combines the previous two requests in a single one (just for publishers); <code>publish</code> can be used to start sending media to broadcast to the other participants, while <code>unpublish</code> does the opposite; <code>start</code> allows you to start receiving media from a publisher you've subscribed to previously by means of a <code>join</code> , while <code>pause</code> pauses the delivery of the media; the <code>switch</code> request can be used to change the source of the media flowing over a specific PeerConnection (e.g., I was watching Alice, I want to watch Bob now) without having to create a new handle for that; finally, <code>leave</code> allows you to leave a video room for good (or, in the case of viewers, definitely closes a subscription).</p>
<p><code>create</code> can be used to create a new video room, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "create",
        "room" : &lt;unique numeric ID, optional, chosen by plugin if missing&gt;,
        "permanent" : &lt;true|false, whether the room should be saved in the config file, default=false&gt;,
        "description" : "&lt;pretty name of the room, optional&gt;",
        "secret" : "&lt;password required to edit/destroy the room, optional&gt;",
        "pin" : "&lt;password required to join the room, optional&gt;",
        "is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "allowed" : [ array of string tokens users can use to join this room, optional],
        ...
}
</pre><p>For the sake of brevity, not all of the available settings are listed here. You can refer to the name of the properties in the configuration file as a reference, as the ones used to programmatically create a new room are exactly the same.</p>
<p>A successful creation procedure will result in a <code>created</code> response:</p>
<pre class="fragment">{
        "videoroom" : "created",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if saved to config file, false if not&gt;
}
</pre><p>If you requested a permanent room but a <code>false</code> value is returned instead, good chances are that there are permission problems.</p>
<p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Notice that, in general, all users can create rooms. If you want to limit this functionality, you can configure an admin <code>admin_key</code> in the plugin settings. When configured, only "create" requests that include the correct <code>admin_key</code> value in an "admin_key" property will succeed, and will be rejected otherwise. Notice that you can optionally extend this functionality to RTP forwarding as well, in order to only allow trusted clients to use that feature.</p>
<p>Once a room has been created, you can still edit some (but not all) of its properties using the <code>edit</code> request. This allows you to modify the room description, secret, pin and whether it's private or not: you won't be able to modify other more static properties, like the room ID, the sampling rate, the extensions-related stuff and so on. If you're interested in changing the ACL, instead, check the <code>allowed</code> message. An <code>edit</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "edit",
        "room" : &lt;unique numeric ID of the room to edit&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "new_description" : "&lt;new pretty name of the room, optional&gt;",
        "new_secret" : "&lt;new password required to edit/destroy the room, optional&gt;",
        "new_pin" : "&lt;new password required to join the room, optional&gt;",
        "new_is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "new_require_pvtid" : &lt;true|false, whether the room should require private_id from subscribers&gt;,
        "new_bitrate" : &lt;new bitrate cap to force on all publishers (except those with custom overrides)&gt;,
        "new_fir_freq" : &lt;new period for regular PLI keyframe requests to publishers&gt;,
        "new_publishers" : &lt;new cap on the number of concurrent active WebRTC publishers&gt;,
        "new_lock_record" : &lt;true|false, whether recording state can only be changed when providing the room secret&gt;,
        "new_rec_dir" : "&lt;the new path where the next .mjr files should being saved&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful edit procedure will result in an <code>edited</code> response:</p>
<pre class="fragment">{
        "videoroom" : "edited",
        "room" : &lt;unique numeric ID&gt;
}
</pre><p>On the other hand, <code>destroy</code> can be used to destroy an existing video room, whether created dynamically or statically, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "destroy",
        "room" : &lt;unique numeric ID of the room to destroy&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful destruction procedure will result in a <code>destroyed</code> response:</p>
<pre class="fragment">{
        "videoroom" : "destroyed",
        "room" : &lt;unique numeric ID&gt;
}
</pre><p>This will also result in a <code>destroyed</code> event being sent to all the participants in the video room, which will look like this:</p>
<pre class="fragment">{
        "videoroom" : "destroyed",
        "room" : &lt;unique numeric ID of the destroyed room&gt;
}
</pre><p>You can check whether a room exists using the <code>exists</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "exists",
        "room" : &lt;unique numeric ID of the room to check&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "exists" : &lt;true|false&gt;
}
</pre><p>You can configure whether to check tokens or add/remove people who can join a room using the <code>allowed</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "allowed",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "action" : "enable|disable|add|remove",
        "room" : &lt;unique numeric ID of the room to update&gt;,
        "allowed" : [
                // Array of strings (tokens users might pass in "join", only for add|remove)
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "allowed" : [
                // Updated, complete, list of allowed tokens (only for enable|add|remove)
        ]
}
</pre><p>If you're the administrator of a room (that is, you created it and have access to the secret) you can kick participants using the <code>kick</code> request. Notice that this only kicks the user out of the room, but does not prevent them from re-joining: to ban them, you need to first remove them from the list of authorized users (see <code>allowed</code> request) and then <code>kick</code> them. The <code>kick</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "kick",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to kick&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
}
</pre><p>As an administrator, you can also forcibly mute/unmute any of the media streams sent by participants (i.e., audio, video and data streams), using the <code>moderate</code> requests. Notice that if the participant is self muted on a stream, and you unmute that stream with <code>moderate</code>, they will NOT be unmuted: you'll simply remove any moderation block that may have been enforced on the participant for that medium themselves. The <code>moderate</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "moderate",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to moderate&gt;,
        "mid" : &lt;mid of the m-line to refer to for this moderate request&gt;,
        "mute" : &lt;true|false, depending on whether the media addressed by the above mid should be muted by the moderator&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
}
</pre><p>To get a list of the available rooms you can make use of the <code>list</code> request. <code>admin_key</code> is optional. If included and correct, rooms configured/created as private will be included in the list as well.</p>
<pre class="fragment">{
        "request" : "list"
}
</pre><p>A successful request will produce a list of rooms in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "list" : [              // Array of room objects
                {       // Room #1
                        "room" : &lt;unique numeric ID&gt;,
                        "description" : "&lt;Name of the room&gt;",
                        "pin_required" : &lt;true|false, whether a PIN is required to join this room&gt;,
                        "is_private" : &lt;true|false, whether this room is 'private' (as in hidden) or not&gt;,
                        "max_publishers" : &lt;how many publishers can actually publish via WebRTC at the same time&gt;,
                        "bitrate" : &lt;bitrate cap that should be forced (via REMB) on all publishers by default&gt;,
                        "bitrate_cap" : &lt;true|false, whether the above cap should act as a limit to dynamic bitrate changes by publishers (optional)&gt;,
                        "fir_freq" : &lt;how often a keyframe request is sent via PLI/FIR to active publishers&gt;,
                        "require_pvtid": &lt;true|false, whether subscriptions in this room require a private_id&gt;,
                        "require_e2ee": &lt;true|false, whether end-to-end encrypted publishers are required&gt;,
                        "dummy_publisher": &lt;true|false, whether a dummy publisher exists for placeholder subscriptions&gt;,
                        "notify_joining": &lt;true|false, whether an event is sent to notify all participants if a new participant joins the room&gt;,
                        "audiocodec" : "&lt;comma separated list of allowed audio codecs&gt;",
                        "videocodec" : "&lt;comma separated list of allowed video codecs&gt;",
                        "opus_fec": &lt;true|false, whether inband FEC must be negotiated (note: only available for Opus) (optional)&gt;,
                        "opus_dtx": &lt;true|false, whether DTX must be negotiated (note: only available for Opus) (optional)&gt;,
                        "record" : &lt;true|false, whether the room is being recorded&gt;,
                        "rec_dir" : "&lt;if recording, the path where the .mjr files are being saved&gt;",
                        "lock_record" : &lt;true|false, whether the room recording state can only be changed providing the secret&gt;,
                        "num_participants" : &lt;count of the participants (publishers, active or not; not subscribers)&gt;
                        "audiolevel_ext": &lt;true|false, whether the ssrc-audio-level extension must be negotiated or not for new publishers&gt;,
                        "audiolevel_event": &lt;true|false, whether to emit event to other users about audiolevel&gt;,
                        "audio_active_packets": &lt;amount of packets with audio level for checkup (optional, only if audiolevel_event is true)&gt;,
                        "audio_level_average": &lt;average audio level (optional, only if audiolevel_event is true)&gt;,
                        "videoorient_ext": &lt;true|false, whether the video-orientation extension must be negotiated or not for new publishers&gt;,
                        "playoutdelay_ext": &lt;true|false, whether the playout-delay extension must be negotiated or not for new publishers&gt;,
                        "transport_wide_cc_ext": &lt;true|false, whether the transport wide cc extension must be negotiated or not for new publishers&gt;
                },
                // Other rooms
        ]
}
</pre><p>To get a list of the participants in a specific room, instead, you can make use of the <code>listparticipants</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listparticipants",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of participants in a <code>participants</code> response:</p>
<pre class="fragment">{
        "videoroom" : "participants",
        "room" : &lt;unique numeric ID of the room&gt;,
        "participants" : [              // Array of participant objects
                {       // Participant #1
                        "id" : &lt;unique numeric ID of the participant&gt;,
                        "display" : "&lt;display name of the participant, if any; optional&gt;",
                        "metadata" : &lt;valid json object of metadata, if any; optional&gt;,
                        "publisher" : "&lt;true|false, whether user is an active publisher in the room&gt;",
                        "talking" : &lt;true|false, whether user is talking or not (only if audio levels are used)&gt;
                },
                // Other participants
        ]
}
</pre><p>This covers almost all the synchronous requests. All the asynchronous requests, plus a couple of additional synchronous requests we'll cover later, refer to participants instead, namely on how they can publish, subscribe, or more in general manage the media streams they may be sending or receiving.</p>
<p>Considering the different nature of publishers and subscribers in the room, and more importantly how you establish PeerConnections in the respective cases, their API requests are addressed in separate subsections.</p>
<h2><a class="anchor" id="vroompub"></a>
VideoRoom Publishers</h2>
<p>In a VideoRoom, publishers are those participant handles that are able (although may choose not to, more on this later) publish media in the room, and as such become feeds that you can subscribe to.</p>
<p>To specify that a handle will be associated with a publisher, you must use the <code>join</code> request with <code>ptype</code> set to <code>publisher</code> (note that, as it will be explained later, you can also use <code>joinandconfigure</code> for the purpose). The exact syntax of the request is the following:</p>
<pre class="fragment">{
        "request" : "join",
        "ptype" : "publisher",
        "room" : &lt;unique ID of the room to join&gt;,
        "id" : &lt;unique ID to register for the publisher; optional, will be chosen by the plugin if missing&gt;,
        "display" : "&lt;display name for the publisher; optional&gt;",
        "token" : "&lt;invitation token, in case the room has an ACL; optional&gt;",
        "metadata" : &lt;valid json object with metadata; optional&gt;
}
</pre><p>This will add the user to the list of participants in the room, although in a non-active role for the time being. Anyway, this participation allows the user to receive notifications about several aspects of the room on the related handle (including streams as they become available and go away). As such, it can be used even just as a way to get notifications in a room, without the need of ever actually publishing any stream at all (which explains why the "publisher" role may actually be a bit confusing in this context).</p>
<p>A successful <code>join</code> will result in a <code>joined</code> event, which will contain a list of the currently active (as in publishing via WebRTC) publishers, and optionally a list of passive attendees (but only if the room was configured with <code>notify_joining</code> set to <code>TRUE</code> ):</p>
<pre class="fragment">{
        "videoroom" : "joined",
        "room" : &lt;room ID&gt;,
        "description" : &lt;description of the room, if available&gt;,
        "id" : &lt;unique ID of the participant&gt;,
        "private_id" : &lt;a different unique ID associated to the participant; meant to be private&gt;,
        "publishers" : [
                {
                        "id" : &lt;unique ID of active publisher #1&gt;,
                        "display" : "&lt;display name of active publisher #1, if any&gt;",
                        "metadata" : &lt;valid json object of metadata, if any&gt;,
                        "dummy" : &lt;true if this participant is a dummy publisher&gt;,
                        "streams" : [
                                {
                                        "type" : "&lt;type of published stream #1 (audio|video|data)"&gt;,
                                        "mindex" : "&lt;unique mindex of published stream #1&gt;",
                                        "mid" : "&lt;unique mid of of published stream #1&gt;",
                                        "disabled" : &lt;if true, it means this stream is currently inactive/disabled (and so codec, description, etc. will be missing)&gt;,
                                        "codec" : "&lt;codec used for published stream #1&gt;",
                                        "description" : "&lt;text description of published stream #1, if any&gt;",
                                        "moderated" : &lt;true if this stream audio has been moderated for this participant&gt;,
                                        "simulcast" : "&lt;true if published stream #1 uses simulcast&gt;",
                                        "svc" : "&lt;true if published stream #1 uses SVC (VP9 and AV1 only)&gt;",
                                        "talking" : &lt;true|false, whether the publisher stream has audio activity or not (only if audio levels are used)&gt;,
                                },
                                // Other streams, if any
                        ],
                        "talking" : &lt;true|false, whether the publisher is talking or not (only if audio levels are used); deprecated, use the stream specific ones&gt;,
                },
                // Other active publishers
        ],
        "attendees" : [         // Only present when notify_joining is set to TRUE for rooms
                {
                        "id" : &lt;unique ID of attendee #1&gt;,
                        "display" : "&lt;display name of attendee #1, if any&gt;",
                        "metadata" : &lt;valid json object of metadata, if any&gt;
                },
                // Other attendees
        ]
}
</pre><p>Notice that the publishers list will of course be empty if no one is currently active in the room. For what concerns the <code>private_id</code> property, it is meant to be used by the user when they create subscriptions, so that the plugin can associate subscriber handles (which are typically anonymous) to a specific participant; they're usually optional, unless required by the room configuration.</p>
<p>As explained, with a simple <code>join</code> you're not an active publisher (there is no WebRTC PeerConnection yet), which means that by default your presence is not notified to other participants. In fact, the publish/subscribe nature of the plugin implies that by default only active publishers are notified, to allow participants to subscribe to existing feeds: notifying all joins/leaves, even those related to who will just lurk, may be overly verbose and chatty, especially in large rooms. Anyway, rooms can be configured to notify those as well, if the <code>notify_joining</code> property is set to true: in that case, regular joins will be notified too, in an event formatted like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "room" : &lt;room ID&gt;,
        "joining" : {
                "id" : &lt;unique ID of the new participant&gt;,
                "display" : "&lt;display name of the new participant, if any&gt;",
                "metadata" : &lt;valid json object of metadata, if any&gt;
        }
}
</pre><p>If you're interested in publishing media within a room, you can do that with a <code>publish</code> request. This request MUST be accompanied by a JSEP SDP offer to negotiate a new PeerConnection. The plugin will match it to the room configuration (e.g., to make sure the codecs you negotiated are allowed in the room), and will reply with a JSEP SDP answer to close the circle and complete the setup of the PeerConnection. As soon as the PeerConnection has been established, the publisher will become active, and a new active feed other participants can subscribe to.</p>
<p>The syntax of a <code>publish</code> request is the following:</p>
<pre class="fragment">{
        "request" : "publish",
        "audiocodec" : "&lt;audio codec to prefer among the negotiated ones; optional&gt;",
        "videocodec" : "&lt;video codec to prefer among the negotiated ones; optional&gt;",
        "bitrate" : &lt;bitrate cap to return via REMB; optional, overrides the global room value if present&gt;,
        "record" : &lt;true|false, whether this publisher should be recorded or not; optional&gt;,
        "filename" : "&lt;if recording, the base path/file to use for the recording files; optional&gt;",
        "display" : "&lt;display name to use in the room; optional&gt;",
        "metadata" : &lt;valid json object of metadata; optional&gt;,
        "audio_level_average" : "&lt;if provided, overrides the room audio_level_average for this user; optional&gt;",
        "audio_active_packets" : "&lt;if provided, overrides the room audio_active_packets for this user; optional&gt;",
        "descriptions" : [      // Optional
                {
                        "mid" : "&lt;unique mid of a stream being published&gt;",
                        "description" : "&lt;text description of the stream (e.g., My front webcam)&gt;"
                },
                // Other descriptions, if any
        ]}
</pre><p>As anticipated, since this is supposed to be accompanied by a JSEP SDP offer describing the publisher's media streams, the plugin will negotiate and prepare a matching JSEP SDP answer. Notice that, in principle, all published streams will be only identified by their unique <code>mid</code> and by their type (e.g., audio or video). In case you want to provide more information about the streams being published (e.g., to let other participants know that the first video is a camera, while the second video is a screen share), you can use the <code>descriptions</code> array for the purpose: each object in the array can be used to add a text description to associate to a specific mid, in order to help with the UI rendering. The <code>descriptions</code> property is optional, so no text will be provided by default: notice these descriptions can be updated dynamically via <code>configure</code> requests.</p>
<p>If successful, a <code>configured</code> event will be sent back, formatted like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "configured" : "ok"
}
</pre><p>This event will be accompanied by the prepared JSEP SDP answer.</p>
<p>Notice that you can also use <code>configure</code> as a request instead of <code>publish</code> to start publishing. The two are functionally equivalent for publishing, but from a semantic perspective <code>publish</code> is the right message to send when publishing. The <code>configure</code> request, as it will be clearer later, can also be used to update some properties of the publisher session: in this case the <code>publish</code> request can NOT be used, as it can only be invoked to publish, and will fail if you're already publishing something.</p>
<p>As an additional note, notice that you can also join and publish in a single request, which is useful in case you're not interested in first join as a passive attendee and only later publish something, but want to publish something right away. In this case you can use the <code>joinandconfigure</code> request, which as you can imagine combines the properties of both <code>join</code> and <code>publish</code> in a single request: the response to a <code>joinandconfigure</code> will be a <code>joined</code> event, and will again be accompanied by a JSEP SDP answer as usual.</p>
<p>However you decided to publish something, as soon as the PeerConnection setup succeeds and the publisher becomes active, an event is sent to all the participants in the room with information on the new feed. The event must contain an array with a single element, and be formatted like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "room" : &lt;room ID&gt;,
        "publishers" : [
                {
                        "id" : &lt;unique ID of the new publisher&gt;,
                        "display" : "&lt;display name of the new publisher, if any&gt;",
                        "metadata" : &lt;valid json object of metadata, if any&gt;,
                        "dummy" : &lt;true if this participant is a dummy publisher&gt;,
                        "streams" : [
                                {
                                        "type" : "&lt;type of published stream #1 (audio|video|data)"&gt;,
                                        "mindex" : "&lt;unique mindex of published stream #1&gt;",
                                        "mid" : "&lt;unique mid of of published stream #1&gt;",
                                        "disabled" : &lt;if true, it means this stream is currently inactive/disabled (and so codec, description, etc. will be missing)&gt;,
                                        "codec" : "&lt;codec used for published stream #1&gt;",
                                        "description" : "&lt;text description of published stream #1, if any&gt;",
                                        "moderated" : &lt;true if this stream audio has been moderated for this participant&gt;,
                                        "simulcast" : "&lt;true if published stream #1 uses simulcast&gt;",
                                        "svc" : "&lt;true if published stream #1 uses SVC (VP9 and AV1 only)&gt;",
                                        "talking" : &lt;true|false, whether the publisher stream has audio activity or not (only if audio levels are used)&gt;,
                                },
                                // Other streams, if any
                        ],
                        "talking" : &lt;true|false, whether the publisher is talking or not (only if audio levels are used); deprecated, use the stream specific ones&gt;,
                }
        ]
}
</pre><p>To stop publishing and tear down the related PeerConnection, you can use the <code>unpublish</code> request, which requires no arguments as the context is implicit:</p>
<pre class="fragment">{
        "request" : "unpublish"
}
</pre><p>This will have the plugin tear down the PeerConnection, and remove the publisher from the list of active streams. If successful, the response will look like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "unpublished" : "ok"
}
</pre><p>As soon as the PeerConnection is gone, all the other participants will also be notified about the fact that the stream is no longer available:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "room" : &lt;room ID&gt;,
        "unpublished" : &lt;unique ID of the publisher who unpublished&gt;
}
</pre><p>Notice that the same event will also be sent whenever the publisher feed disappears for reasons other than an explicit <code>unpublish</code> , e.g., because the handle was closed or the user lost their connection. Besides, notice that you can publish and unpublish multiple times within the context of the same publisher handle.</p>
<p>As anticipated above, you can use a request called <code>configure</code> to tweak some of the properties of an active publisher session. This request must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "configure",
        "bitrate" : &lt;bitrate cap to return via REMB; optional, overrides the global room value if present (unless bitrate_cap is set)&gt;,
        "keyframe" : &lt;true|false, whether we should send this publisher a keyframe request&gt;,
        "record" : &lt;true|false, whether this publisher should be recorded or not; optional&gt;,
        "filename" : "&lt;if recording, the base path/file to use for the recording files; optional&gt;",
        "display" : "&lt;new display name to use in the room; optional&gt;",
        "metadata" : &lt;new metadata json object; optional&gt;,
        "audio_active_packets" : "&lt;new audio_active_packets to overwrite in the room one; optional&gt;",
        "audio_level_average" : "&lt;new audio_level_average to overwrite the room one; optional&gt;",
        "streams" : [
                {
                        "mid" : &lt;mid of the m-line to tweak&gt;,
                        "keyframe" : &lt;true|false, whether we should send this stream a keyframe request; optional&gt;,
                        "send" : &lt;true|false, depending on whether the media addressed by the above mid should be relayed or not; optional&gt;,
                        "min_delay" : &lt;minimum delay to enforce via the playout-delay RTP extension, in blocks of 10ms; optional&gt;,
                        "max_delay" : &lt;maximum delay to enforce via the playout-delay RTP extension, in blocks of 10ms; optional&gt;
                },
                // Other streams, if any
        ],
        "descriptions" : [
                // Updated descriptions for the published streams; see "publish" for syntax; optional
        ]
}
</pre><p>As you can see, it's basically the same properties as those listed for <code>publish</code> , with the addition of a <code>streams</code> array that can be used to tweak individual streams (which is not available when publishing since in that case the stream doesn't exist yet). Notice that the <code>configure</code> request can also be used in renegotiations, to provide an updated SDP with changes to the published media. If successful, a <code>configured</code> event will be sent back as before, formatted like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "configured" : "ok"
}
</pre><p>When configuring the room to request the ssrc-audio-level RTP extension, ad-hoc events might be sent to all publishers if <code>audiolevel_event</code> is set to true. These events will have the following format:</p>
<pre class="fragment">{
        "videoroom" : &lt;"talking"|"stopped-talking", whether the publisher started or stopped talking&gt;,
        "room" : &lt;unique numeric ID of the room the publisher is in&gt;,
        "id" : &lt;unique numeric ID of the publisher&gt;,
        "audio-level-dBov-avg" : &lt;average value of audio level, 127=muted, 0='too loud'&gt;
}
</pre><p>An interesting feature VideoRoom publisher can take advantage of is RTP forwarding. In fact, while the main purpose of this plugin is getting media from WebRTC sources (publishers) and relaying it to WebRTC destinations (subscribers), there are actually several use cases and scenarios for making this media available to external, notnecessarily WebRTC-compliant, components. These components may benefit from having access to the RTP media sent by a publisher, e.g., for media processing, external recording, transcoding to other technologies via other applications, scalability purposes or whatever else makes sense in this context. This is made possible by a request called <code>rtp_forward</code> which, as the name suggests, simply forwards in real-time the media sent by a publisher via RTP (plain or encrypted) to a remote backend. Notice that, although we're using the term "RTP forwarder", this feature can be used to forward data channel messages as well.</p>
<p>You can add a new RTP forwarder for an existing publisher using the <code>rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "rtp_forward",
        "room" : &lt;unique numeric ID of the room the publisher is in&gt;,
        "publisher_id" : &lt;unique numeric ID of the publisher to relay externally&gt;,
        "host" : "&lt;host address to forward the RTP and data packets to&gt;",
        "host_family" : "&lt;ipv4|ipv6, if we need to resolve the host address to an IP; by default, whatever we get&gt;",
        "streams" : [
                {
                        "mid" : "&lt;mid of publisher stream to forward&gt;",
                        "host" : "&lt;host address to forward the packets to; optional, will use global one if missing&gt;",
                        "host_family" : "&lt;optional, will use global one if missing&gt;",
                        "port" : &lt;port to forward the packets to&gt;,
                        "ssrc" : &lt;SSRC to use to use when forwarding; optional, and only for RTP streams, not data&gt;,
                        "pt" : &lt;payload type to use when forwarding; optional, and only for RTP streams, not data&gt;,
                        "rtcp_port" : &lt;port to contact to receive RTCP feedback from the recipient; optional, and only for RTP streams, not data&gt;,
                        "simulcast" : &lt;true|false, set to true if the source is simulcast and you want the forwarder to act as a regular viewer (single stream being forwarded) or false otherwise (substreams forwarded separately); optional, default=false&gt;,
                        "port_2" : &lt;if video and simulcasting, port to forward the packets from the second substream/layer to&gt;,
                        "ssrc_2" : &lt;if video and simulcasting, SSRC to use to use the second substream/layer; optional&gt;,
                        "pt_2" : &lt;if video and simulcasting, payload type to use the second substream/layer; optional&gt;,
                        "port_3" : &lt;if video and simulcasting, port to forward the packets from the third substream/layer to&gt;,
                        "ssrc_3" : &lt;if video and simulcasting, SSRC to use to use the third substream/layer; optional&gt;,
                        "pt_3" : &lt;if video and simulcasting, payload type to use the third substream/layer; optional&gt;,
                },
                {
                        .. other streams, if needed..
                }
        ],
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;"
}
</pre><p>As you can see, you basically configure each stream to forward in a dedicated object of the <code>streams</code> array: for RTP streams (audio, video) this includes optionally overriding payload type or SSRC; simulcast streams can be forwarded separately for each layer. The only parameters you MUST specify are the host and port to send the packets to: the host part can be put in the global part of the request, if all streams will be sent to the same IP address, while the port must be specific to the stream itself.</p>
<p>Notice that, as explained above, in case you configured an <code>admin_key</code> property and extended it to RTP forwarding as well, you'll need to provide it in the request as well or it will be rejected as unauthorized. By default no limitation is posed on <code>rtp_forward</code> .</p>
<p>It's worth spending some more words on how to forward simulcast publishers, as this can lead to some confusion. There are basically two ways to forward a simulcast publisher:</p>
<ol type="1">
<li>you treat the forwarder as a regular viewer, which means you still only forward a single stream to the recipient, that is the highest quality available at any given time: you can do that by setting <code>simulcast: true</code> in the <code>rtp_forward</code> request;</li>
<li>you forward each substream separately instead, to different target ports: you do that by specifying <code>video_port_2</code> , <code>video_port_3</code> and optionally the other related <code>_2</code> and <code>_3</code> properties; this is what you should use when you want to forward to a simulcast-aware Streaming mountpoint (see the <a class="el" href="streaming.html">Streaming plugin documentation</a> for more details).</li>
</ol>
<p>The two approaches are mutually exclusive: you can NOT use them together in the same RTP forwarder.</p>
<p>A successful request will result in an <code>rtp_forward</code> response, containing the relevant info associated to the new forwarder(s):</p>
<pre class="fragment">{
        "videoroom" : "rtp_forward",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "publisher_id" : &lt;unique numeric ID, same as request&gt;,
        "forwarders" : [
                {
                        "stream_id" : &lt;unique numeric ID assigned to this forwarder, if any&gt;,
                        "type" : "&lt;audio|video|data&gt;",
                        "host" : "&lt;host this forwarder is streaming to, same as request if not resolved&gt;",
                        "port" : &lt;port this forwarder is streaming to, same as request if configured&gt;,
                        "local_rtcp_port" : &lt;local port this forwarder is using to get RTCP feedback, if any&gt;,
                        "remote_rtcp_port" : &lt;remote port this forwarder is getting RTCP feedback from, if any&gt;,
                        "ssrc" : &lt;SSRC this forwarder is using, same as request if configured&gt;,
                        "pt" : &lt;payload type this forwarder is using, same as request if configured&gt;,
                        "substream" : &lt;video substream this video forwarder is relaying, if any&gt;,
                        "srtp" : &lt;true|false, whether the RTP stream is encrypted (not used for data)&gt;
                },
                // Other forwarders, if configured
        ]
}
</pre><p>To stop a previously created RTP forwarder and stop it, you can use the <code>stop_rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "stop_rtp_forward",
        "room" : &lt;unique numeric ID of the room the publisher is in&gt;,
        "publisher_id" : &lt;unique numeric ID of the publisher to update&gt;,
        "stream_id" : &lt;unique numeric ID of the RTP forwarder&gt;
}
</pre><p>A successful request will result in a <code>stop_rtp_forward</code> response:</p>
<pre class="fragment">{
        "videoroom" : "stop_rtp_forward",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "publisher_id" : &lt;unique numeric ID, same as request&gt;,
        "stream_id" : &lt;unique numeric ID, same as request&gt;
}
</pre><p>To get a list of all the forwarders in a specific room, instead, you can make use of the <code>listforwarders</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listforwarders",
        "room" : &lt;unique numeric ID of the room&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;"
}
</pre><p>A successful request will produce a list of RTP forwarders in a <code>forwarders</code> response:</p>
<pre class="fragment">{
        "videoroom" : "forwarders",
        "room" : &lt;unique numeric ID of the room&gt;,
        "publishers" : [                // Array of publishers with RTP forwarders
                {       // Publisher #1
                        "publisher_id" : &lt;unique numeric ID of publisher #1&gt;,
                        "forwarders" : [                // Array of RTP forwarders
                                {       // RTP forwarder #1
                                        "stream_id" : &lt;unique numeric ID assigned to this RTP forwarder, if any&gt;,
                                        "type" : "&lt;audio|video|data&gt;",
                                        "host" : "&lt;host this forwarder is streaming to&gt;",
                                        "port" : &lt;port this forwarder is streaming to&gt;,
                                        "local_rtcp_port" : &lt;local port this forwarder is using to get RTCP feedback, if any&gt;,
                                        "remote_rtcp_port" : &lt;remote port this forwarder getting RTCP feedback from, if any&gt;,
                                        "ssrc" : &lt;SSRC this forwarder is using, if any&gt;,
                                        "pt" : &lt;payload type this forwarder is using, if any&gt;,
                                        "substream" : &lt;video substream this video forwarder is relaying, if any&gt;,
                                        "srtp" : &lt;true|false, whether the RTP stream is encrypted&gt;
                                },
                                // Other forwarders for this publisher
                        ],
                },
                // Other publishers
        ]
}
</pre><p>To enable or disable recording on all participants while the conference is in progress, you can make use of the <code>enable_recording</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "enable_recording",
        "room" : &lt;unique numeric ID of the room&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;"
        "record" : &lt;true|false, whether participants in this room should be automatically recorded or not&gt;,
}
</pre><p>Notice that, as we'll see later, participants can normally change their own recording state via <code>configure</code> requests as well: this was done to allow the maximum flexibility, where rather than globally or automatically record something, you may want to individually record some streams and to a specific file. That said, if you'd rather ensure that participants can't stop their recording if a global recording is enabled, or start it when the room is not supposed to be recorded instead, then you should make sure the room is created with the <code>lock_record</code> property set to <code>true</code> : this way, the recording state can only be changed if the room secret is provided, thus ensuring that only an administrator will normally be able to do that (e.g., using the <code>enable_recording</code> just introduced).</p>
<p>To conclude, you can leave a room you previously joined as publisher using the <code>leave</code> request. This will also implicitly unpublish you if you were an active publisher in the room. The <code>leave</code> request looks like follows:</p>
<pre class="fragment">{
        "request" : "leave"
}
</pre><p>If successful, the response will look like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "leaving" : "ok"
}
</pre><p>Other participants will receive a "leaving" event to notify them the circumstance:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "room" : &lt;room ID&gt;,
        "leaving : &lt;unique ID of the participant who left&gt;,
        "display" : "&lt;display name of the leaving participant, if any&gt;"
}
</pre><p>If you were an active publisher, other users will also receive the corresponding "unpublished" event to notify them the stream is not longer available, as explained above. If you were simply lurking and not publishing, the other participants will only receive the "leaving" event.</p>
<h2><a class="anchor" id="vroomsub"></a>
VideoRoom Subscribers</h2>
<p>In a VideoRoom, subscribers are NOT participants, but simply handles that will be used exclusively to receive media from one or more publishers in the room. Since they're not participants per se, they're basically streams that can be (and typically are) associated to publisher handles as the ones we introduced in the previous section, whether active or not. In fact, the typical use case is publishers being notified about new participants becoming active in the room, and as a result new subscriber sessions being created to receive their media streams; as soon as the publisher goes away, other participants are notified so that the related subscriber handles can be removed/updated accordingly as well. As such, these subscriber sessions are dependent on feedback obtained by publishers, and can't exist on their own, unless you feed them the right info out of band (which is impossible in rooms configured with <code>require_pvtid</code>).</p>
<p>To specify that a handle will be associated with a subscriber, you must use the <code>join</code> request with <code>ptype</code> set to <code>subscriber</code> and specify which feed to subscribe to. The exact syntax of the request is the following:</p>
<pre class="fragment">{
        "request" : "join",
        "ptype" : "subscriber",
        "room" : &lt;unique ID of the room to subscribe in&gt;,
        "use_msid" : &lt;whether subscriptions should include an msid that references the publisher; false by default&gt;,
        "autoupdate" : &lt;whether a new SDP offer is sent automatically when a subscribed publisher leaves; true by default&gt;,
        "private_id" : &lt;unique ID of the publisher that originated this request; optional, unless mandated by the room configuration&gt;,
        "streams" : [
                {
                        "feed" : &lt;unique ID of publisher owning the stream to subscribe to&gt;,
                        "mid" : "&lt;unique mid of the publisher stream to subscribe to; optional&gt;"
                        "crossrefid" : "&lt;id to map this subscription with entries in streams list; optional&gt;"
                        // Optionally, simulcast or SVC targets (defaults if missing)
                },
                // Other streams to subscribe to
        ]
}
</pre><p>As you can see, it's just a matter of specifying the list of streams to subscribe to: in particular, you have to provide an array of objects, where each objects represents a specific stream (or group of streams) you're interested in. For each object, the <code>feed_id</code> indicating the publisher owning the stream(s) is mandatory, while the related <code>mid</code> is optional: this gives you some flexibility when subscribing, as only providing a <code>feed_id</code> will indicate you're interested in ALL the stream from that publisher, while providing a <code>mid</code> as well will indicate you're interested in a stream in particular. Since you can provide an array of streams, just specifying the <code>feed_id</code> or explicitly listing all the <code>feed_id</code> + <code>mid</code> combinations is equivalent: of course, different objects in the array can indicate different publishers, allowing you to combine streams from different sources in the same subscription. Notice that if a publisher stream is marked as <code>disabled</code> and you try to subscribe to it, it will be skipped silently.</p>
<p>Depending on whether the subscription will refer to a single publisher (legacy approach) or to streams coming from different publishers (multistream), the list of streams may differ. The ability to single out the streams to subscribe to is particularly useful in case you don't want to, or can't, subscribe to all available media: e.g., you know a publisher is sending both audio and video, but video is in a codec you don't support or you don't have bandwidth for both; or maybe there are 10 participants in the room, but you only want video from the 3 most active speakers; and so on. The content of the <code>streams</code> array will shape what the SDP offer the plugin will send will look like, so that eventually a subscription for the specified streams will take place. Notice that, while for backwards compatibility you can still use the old <code>feed</code>, <code>audio</code>, <code>video</code>, <code>data</code>, <code>offer_audio</code>, <code>offer_video</code> and <code>offer_data</code> named properties, they're now deprecated and so you're highly encouraged to use this new drill-down <code>streams</code> list instead.</p>
<p>As anticipated, if successful this request will generate a new JSEP SDP offer, which will accompany an <code>attached</code> event:</p>
<pre class="fragment">{
        "videoroom" : "attached",
        "room" : &lt;room ID&gt;,
        "streams" : [
                {
                        "mindex" : &lt;unique m-index of this stream&gt;,
                        "mid" : "&lt;unique mid of this stream&gt;",
                        "type" : "&lt;type of this stream's media (audio|video|data)&gt;",
                        "active" : &lt;true|false, whether this stream is currently active&gt;,
                        "feed_id" : &lt;unique ID of the publisher originating this stream&gt;,
                        "feed_mid" : "&lt;unique mid of this publisher's stream&gt;",
                        "feed_display" : "&lt;display name of this publisher, if any&gt;",
                        "send" : &lt;true|false; whether we configured the stream to relay media&gt;,
                        "codec" : "&lt;codec used by this stream&gt;",
                        "h264-profile" : "&lt;in case H.264 is used by the stream, the negotiated profile&gt;",
                        "vp9-profile" : "&lt;in case VP9 is used by the stream, the negotiated profile&gt;",
                        "ready" : &lt;true|false; whether this stream is ready to start sending media (will be false at the beginning)&gt;,
                        "simulcast" : { .. optional object containing simulcast info, if simulcast is used by this stream .. },
                        "svc" : { .. optional object containing SVC info, if SVC is used by this stream .. },
                        "playout-delay" : { .. optional object containing info on the playout-delay extension configuration, if in use .. },
                        "sources" : &lt;if this is a data channel stream, the number of data channel subscriptions&gt;,
                        "source_ids" : [ .. if this is a data channel stream, an array containing the IDs of participants we've subscribed to .. ],
                },
                // Other streams in the subscription, if any
        ]
}
</pre><p>As you can see, a summary of the streams we subscribed to will be sent back, which will be useful on the client side for both mapping and rendering purposes.</p>
<p>At this stage, to complete the setup of the PeerConnection the subscriber is supposed to send a JSEP SDP answer back to the plugin. This is done by means of a <code>start</code> request, which in this case MUST be associated with a JSEP SDP answer but otherwise requires no arguments:</p>
<pre class="fragment">{
        "request" : "start"
}
</pre><p>If successful this request returns a <code>started</code> event:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "started" : "ok"
}
</pre><p>Once this is done, all that's needed is waiting for the WebRTC PeerConnection establishment to succeed. As soon as that happens, the VideoRoom plugin can start relaying media the recipient subscribed to.</p>
<p>Once a WebRTC PeerConnection has been established for a subscriber, in case you want to update a subscription you have to use the <code>subscribe</code> , <code>unsubscribe</code> or <code>update</code> methods: as the names of the requests suggest, the former allows you to add more streams to subscribe to, the second instructs the plugin to remove streams you're currently subscribe to, while the latter allows you to perform both operations at the same time. Any of those requests will trigger a renegotiation, if they were successful, meaning the plugin will send you a new JSEP offer you'll have to reply to with an answer: to send the answer, just use the same <code>start</code> request we already described above. Notice that renegotiations may not be triggered right away, e.g., whenever you're trying to update a session and the plugin is still in the process of renegoting a previous update for the same subscription: in that case, an update will be scheduled and a renegotiation will be triggered as soon as it's viable, and an empty <code>updating</code> event will be triggered instead to notify the caller that the management of that request has been postponed. It's also important to point out that the number of offers generated in response to those requests may not match the amount of requests: in fact, since requests are postponed, a single offer may be sent in response to multiple requests to update a subscription at the same time, thus addressing them all in a cumulative way. This means clients should never expect an offer any time they request one.</p>
<p>The syntax of the <code>subscribe</code> mirrors the one for new subscriptions, meaning you use the same <code>streams</code> array to address the new streams you want to receive, and formatted the same way:</p>
<pre class="fragment">{
        "request" : "subscribe",
        "streams" : [
                {
                        "feed" : &lt;unique ID of publisher owning the new stream to subscribe to&gt;,
                        "mid" : "&lt;unique mid of the publisher stream to subscribe to; optional&gt;"
                        "crossrefid" : "&lt;id to map this subscription with entries in streams list; optional&gt;"
                        // Optionally, send, simulcast or SVC targets (defaults if missing)
                },
                // Other new streams to subscribe to
        ]
}
</pre><p>This means the exact same considerations we made on <code>streams</code> before apply here as well: whatever they represent, will indicate the willingness to subscribe to the related stream. Notice that if you were already subscribed to one of the new streams indicated here, you'll subscribe to it again in a different m-line, so it's up to you to ensure you avoid duplicates (unless that's what you wanted, e.g., for testing purposes). In case the update was successful, you'll get an <code>updated</code> event, containing the updated layout of all subscriptions (pre-existing and new ones), and a new JSEP offer to renegotiate the session:</p>
<pre class="fragment">{
        "videoroom" : "updated",
        "room" : &lt;room ID&gt;,
        "streams": [
                {
                        "mindex" : &lt;unique m-index of this stream&gt;,
                        "mid" : "&lt;unique mid of this stream&gt;",
                        "type" : "&lt;type of this stream's media (audio|video|data)&gt;",
                        "feed_id" : &lt;unique ID of the publisher originating this stream&gt;,
                        "feed_mid" : "&lt;unique mid of this publisher's stream&gt;",
                        "feed_display" : "&lt;display name of this publisher, if any&gt;",
                        "send" : &lt;true|false; whether we configured the stream to relay media&gt;,
                        "ready" : &lt;true|false; whether this stream is ready to start sending media (will be false at the beginning)&gt;
                },
                // Other streams in the subscription, if any; old and new
        ]
}
</pre><p>Notice that if your <code>subscribe</code> request didn't change anything as far as the SDP negotiation is concerned (e.g., subscribing to new data streams where a datachannel existed already), you'll simply get an <code>updated</code> event back with no <code>streams</code> object.</p>
<p>As explained before, in case the message contains a JSEP offer (which may not be the case if no change occurred), then clients will need to send a new JSEP answer with a <code>start</code> request to close this renegotiation.</p>
<p>The <code>unsubscribe</code> request works pretty much the same way, with the difference that the <code>streams</code> array you provide to specify what to unsubscribe from may look different. Specifically, the syntax looks like this:</p>
<pre class="fragment">{
        "request" : "unsubscribe",
        "streams" : [
                {
                        "feed" : &lt;unique ID of publisher owning the new stream to unsubscribe from; optional&gt;,
                        "mid" : "&lt;unique mid of the publisher stream to unsubscribe from; optional&gt;"
                        "sub_mid" : "&lt;unique mid of the subscriber stream to unsubscribe; optional&gt;"
                },
                // Other streams to unsubscribe from
        ]
}
</pre><p>This means that you have different ways to specify what to unsubscribe from: if an object only specifies <code>feed_id</code>, then all the subscription streams that were receiving media from that publisher will be removed; if an object specifies <code>feed_id</code> and <code>mid</code>, then all the subscription streams that were receiving media from the publisher stream with the related mid will be removed; finally, if an object only specifies <code>sub_mid</code> instead, then only the stream in the subscription that is addressed by the related mid (subscription mid, no relation to the publishers') will be removed. As such, you have a great deal of flexibility in how to unsubscribe from media. Notice that multiple streams may be removed in case you refer to the "source" ( <code>feed_id</code> ), rather than the "sink" ( <code>sub_mid</code> ), especially in case the subscription contained duplicates or multiple streams from the same publisher.</p>
<p>A successful <code>unsubscribe</code> will result in exactly the same <code>updated</code> event <code>subscribe</code> triggers, so the same considerations apply with respect to the potential need of a renegotiation and how to complete it with a <code>start</code> along a JSEP answer. Again, if <code>unsubscribe</code> didn't result in SDP changes (e.g., unsubscribing from a data channel stream), you'll simply get an <code>updated</code> event back with no <code>streams</code> object.</p>
<p>As anticipated, the <code>update</code> request allows you to combine changes to a subscription where you may want to both subscribe to new streams, and unsubscribe from existing ones, which the existing <code>subscribe</code> and <code>unsubscribe</code> requests wouldn't allow you to do as they work exclusively on the action specified by their name. The syntax for the <code>update</code> request is very similar to the previous method, meaning arrays are still used to address the streams to work on, with the key difference that they won't be named <code>streams</code>, but <code>subscribe</code> and <code>unsubscribe</code> instead:</p>
<pre class="fragment">{
        "request" : "update",
        "subscribe" : [
                {
                        "feed" : &lt;unique ID of publisher owning the new stream to subscribe to&gt;,
                        "mid" : "&lt;unique mid of the publisher stream to subscribe to; optional&gt;"
                        "crossrefid" : "&lt;id to map this subscription with entries in streams list; optional&gt;"
                        // Optionally, send, simulcast or SVC targets (defaults if missing)
                },
                // Other new streams to subscribe to
        ],
        "unsubscribe" : [
                {
                        "feed" : &lt;unique ID of publisher owning the new stream to unsubscribe from; optional&gt;,
                        "mid" : "&lt;unique mid of the publisher stream to unsubscribe from; optional&gt;"
                        "sub_mid" : "&lt;unique mid of the subscriber stream to unsubscribe; optional&gt;"
                },
                // Other streams to unsubscribe from
        ]
}
</pre><p>Both the <code>subscribe</code> and <code>unsubscribe</code> arrays are optional, which means that an <code>update</code> request to only subscribe to new streams will be functionally equivalent to a <code>subscribe</code> request, and an <code>update</code> request to only unsubscribe will be functionally equivalent to an <code>unsubscribe</code> request instead. That said, one of the two must be provided, which means that an <code>update</code> request that doesn't include either of them will result in an error.</p>
<p>A successful <code>update</code> will result in exactly the same <code>updated</code> event <code>subscribe</code> and <code>unsubscribe</code> trigger, so the same considerations apply with respect to the potential need of a renegotiation and how to complete it with a <code>start</code> along a JSEP answer. Again, if <code>update</code> didn't result in SDP changes, you'll simply get an <code>updated</code> event back with no <code>streams</code> object.</p>
<p>Notice that, in case you want to trigger an ICE restart rather than updating a subscription, you'll have to use a different request, named <code>configure:</code> this will be explained in a few paragraphs.</p>
<p>As a subscriber, you can temporarily pause and resume the whole media delivery with a <code>pause</code> and, again, <code>start</code> request (in this case without any JSEP SDP answer attached). Neither expect other arguments, as the context is implicitly derived from the handle they're sent on:</p>
<pre class="fragment">{
        "request" : "pause"
}
</pre><pre class="fragment">{
        "request" : "start"
}
</pre><p>Unsurprisingly, they just result in, respectively, <code>paused</code> and <code>started</code> events:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "paused" : "ok"
}
</pre><pre class="fragment">{
        "videoroom" : "event",
        "started" : "ok"
}
</pre><p>For more drill-down manipulations of a subscription, a <code>configure</code> request can be used instead. This request allows subscribers to dynamically change some properties associated to their media subscription, e.g., in terms of what should and should not be sent at a specific time. A <code>configure</code> request must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "configure",
        "streams" : [
                {
                        "mid" : &lt;mid of the m-line to refer to&gt;,
                        "send" : &lt;true|false, depending on whether the mindex media should be relayed or not; optional&gt;,
                        "substream" : &lt;substream to receive (0-2), in case simulcasting is enabled; optional&gt;,
                        "temporal" : &lt;temporal layers to receive (0-2), in case simulcasting is enabled; optional&gt;,
                        "fallback" : &lt;How much time (in us, default 250000) without receiving packets will make us drop to the substream below; optional&gt;,
                        "spatial_layer" : &lt;spatial layer to receive (0-2), in case SVC is enabled; optional&gt;,
                        "temporal_layer" : &lt;temporal layers to receive (0-2), in case SVC is enabled; optional&gt;,
                        "audio_level_average" : "&lt;if provided, overrides the room audio_level_average for this user; optional&gt;",
                        "audio_active_packets" : "&lt;if provided, overrides the room audio_active_packets for this user; optional&gt;",
                        "min_delay" : &lt;minimum delay to enforce via the playout-delay RTP extension, in blocks of 10ms; optional&gt;,
                        "max_delay" : &lt;maximum delay to enforce via the playout-delay RTP extension, in blocks of 10ms; optional&gt;,
                },
                // Other streams, if any
        ],
        "restart" : &lt;trigger an ICE restart; optional&gt;
}
</pre><p>As you can see, the <code>mid</code> and <code>send</code> properties can be used as a media-level pause/resume functionality ("only mute/unmute this mid"), whereas <code>pause</code> and <code>start</code> simply pause and resume all streams at the same time. The <code>substream</code> and <code>temporal</code> properties, instead, only make sense when the publisher is configured with video simulcasting support, and as such the subscriber is interested in receiving a specific substream or temporal layer, rather than any other of the available ones: notice that for them to work you'll have to specify the <code>mid</code> as well, as the same subscription may be receiving simulcast stream from multiple publishers. The <code>spatial_layer</code> and <code>temporal_layer</code> have exactly the same meaning, but within the context of SVC publishers, and will have no effect on subscriptions associated to regular publishers.</p>
<p>As anticipated, <code>configure</code> is also the request you use when you want to trigger an ICE restart for a subscriber: in fact, while publishers can force a restart themselves by providing the right JSEP offer, subscribers always receive an offer from Janus instead, and as such have to explicitly ask for a dedicated offer when an ICE restart is needed; in that case, just set <code>restart</code> to <code>true</code> in a <code>configure</code> request, and a new JSEP offer with ICE restart information will be sent to the client, to which the client will have to reply, as usual, via <code>start</code> along a JSEP answer. This documentation doesn't explain when or why an ICE restart is needed or appropriate: please refer to the ICE RFC or other sources of information for that.</p>
<p>Another interesting feature that subscribers can take advantage of is the so-called publisher "switching". Basically, when subscribed to one or more publishers and receiving media from them, you can at any time "switch" any of the subscription streams to a different publisher, and as such start receiving media on the related m-line from that publisher instead, all without doing a new <code>subscribe</code> or <code>unsubscribe</code>, and so without the need of doing any renegotiation at all; just some logic changes. Think of it as changing channel on a TV: you keep on using the same PeerConnection, the plugin simply changes the source of the media transparently. Of course, while powerful and effective this request has some limitations: in fact, the source (audio or video) that you switch to must have the same media configuration (e.g., same codec) as the source you're replacing. In fact, since the same PeerConnection is used for this feature and no renegotiation is taking place, switching to a stream with a different configuration would result in media incompatible with the PeerConnection setup being relayed to the subscriber (e.g., negotiated VP9, but new source is H.264), and as such in no audio/video being played; in that case, you'll need a <code>subscribe</code> instead, and a new m-line.</p>
<p>That said, a <code>switch</code> request must be formatted like this:</p>
<pre class="fragment">{
        "request" : "switch",
        "streams" : [
                {
                        "feed" : &lt;unique ID of the publisher the new source is from&gt;,
                        "mid" : "&lt;unique mid of the source we want to switch to&gt;",
                        "sub_mid" : "&lt;unique mid of the stream we want to pipe the new source to&gt;"
                        .. other properties, e.g., substream, temporal, etc.
                },
                {
                        // Other updates, if any
                }
        ]
}
</pre><p>While apparently convoluted, this is actually a quite effective and powerful way of updating subscriptions without renegotiating. In fact, it allows for full or partial switches: for instance, sometimes you may want to replace all audio and video streams (e.g., switching from Bob to Alice in a "legacy" VideoRoom usage, where each PeerConnection subscription is a different publisher), or just replace a subset of them (e.g., you have a subscription with three video slots, and you change one of them depending on the loudest speaker). What to replace is dictated by the <code>streams</code> array, where each object in the array contains all the info needed for the switch to take place: in particular, you must specify which of your subscription m-lines you're going to update, via <code>sub_mid</code> , and which publisher stream should now start to feed it via <code>feed</code> and <code>mid</code>.</p>
<p>If successful, the specified subscriptions will be updated, meaning they'll be unsubscribed from the previous publisher stream, and subscribed to the new publisher stream instead, all without a renegotiation (so no new SDP offer/answer exchange to take care of). The event to confirm the switch was successful will look like this:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "switched" : "ok",
        "room" : &lt;room ID&gt;,
        "changes" : &lt;number of successful changes (may be smaller than the size of the streams array provided in the request)&gt;,
        "streams" : [
                // Current configuration of the subscription, same format as when subscribing
                // Will contain info on all streams, not only those that have been updated
        ]
}
</pre><p>Notice that, while a <code>switch</code> request usually doesn't require a renegotiation, it <b>MIGHT</b> trigger one nevertheless: in fact, if a "switch" request assigns a new publisher stream to a previously inactive subscriber stream, then a renegotiation to re-activate that stream will be needed as well, as otherwise the packets from the new source will not be relayed.</p>
<p>Finally, to close a subscription and tear down the related PeerConnection, you can use the <code>leave</code> request. Since context is implicit, no other argument is required:</p>
<pre class="fragment">{
        "request" : "leave"
}
</pre><p>If successful, the plugin will attempt to tear down the PeerConnection, and will send back a <code>left</code> event:</p>
<pre class="fragment">{
        "videoroom" : "event",
        "left" : "ok",
}
</pre><h2><a class="anchor" id="vroomcasc"></a>
Remote publishers (room cascading)</h2>
<p>Normally, the VideoRoom plugin can only route streams associated to users connected to the Janus instance the plugin lives in: this means that, within the context of a room, you can only subscribe to publishers connected to the same server (and room) you're on.</p>
<p>That said, there are obviously ways to address this constraint. In the past, a typical approach for handling this (e.g., for scalability or geo-distribution purposes) was to use the <code>rtp_forward</code> request to feed one or more local/remote Streaming plugin mountpoints, so that a VideoRoom publisher could be consumed using the Streaming plugin instead, possibly on a completely different Janus instance. This works and has been used extensively (by ourselves too), but has the downside that this completely excludes the VideoRoom API in terms of presence and subscriptions: it's up to you, for instance, to advertise these redistributed streams somehow, and associate them to the original publisher from a semantics perspective.</p>
<p>That said, the VideoRoom plugin now also has a concept of remote publishers, that allows you to remotize local VideoRoom publishers to different VideoRoom instances, which can in turn advertise the presence of these remote subscribers along with their local publishers. This allows subscribers to use the VideoRoom API, transparently, to subscribe to both local and remote publishers seamlessly, knowing that the involved VideoRoom instances will exchange the media packets among them to make it happen.</p>
<p>It's important to point out that this is not something that's completely automated: it's still up to you, via API calls, to instruct all involved VideoRoom instances, so that the remotization can happen, and to keep it up do that (e.g., after renegotiations occur).</p>
<p>Specifically, the VideoRoom API exposes the <code>add_remote_publisher</code> , <code>update_remote_publisher</code> , <code>remove_remote_publisher</code> , <code>publish_remotely</code> , <code>unpublish_remotely</code> and <code>list_remotes</code> requests.</p>
<p>Assuming that <b>Janus</b> <b>A</b> wants to make one of its local publishers available in a room on <b>Janus</b> <b>B</b> as well, this is the process you must follow:</p>
<ul>
<li>you use <code>add_remote_publisher</code> on <b>Janus</b> <b>B</b> (the target instance) to add a new remote publisher; this will return some connectivity info to the caller, and immediately advertise the new publisher to other attendees in <b>Janus</b> <b>B</b> even before media actually arrives;</li>
<li>you use <code>publish_remotely</code> on <b>Janus</b> <b>A</b> (the source instance), using the info returned from the previous call; this has the result of instructing <b>Janus</b> <b>A</b> to start relaying all RTP packets associated to that publisher to <b>Janus</b> <b>B</b> ;</li>
<li>any time the publisher on <b>Janus</b> <b>A</b> renegotiates their session (e.g., a new audio or video stream is added, or removed), you should use <code>update_remote_publisher</code> on <b>Janus</b> <b>B</b> so that the remote instance is aware of the changes, and can notify people in the room accordingly (e.g., so that they can update their subscriptions accordingly);</li>
<li>when the publisher on <b>Janus</b> <b>A</b> leaves, an <code>unpublish_remotely</code> request must be sent on <b>Janus</b> <b>A</b> to ensure no media is forwarded anymore, and at the same time a <code>remove_remote_publisher</code> must be sent to <b>Janus</b> <b>B</b> so that other attendees can be notified the participant has left.</li>
</ul>
<p>Using these requests, the two Janus instances will transparently and automatically communicate using internally created RTP forwarders. The same ports are used for all RTP packets, so multiplexing is performed using a simple math on SSRC identifiers: this means that there's no need to open new ports as a consequence of renegotiations of a publisher, but only to notify the recipient about what media is on its way, and demultiplexing will be performed automatically.</p>
<p>Everything else (subscribing to, and unsubscribing from, remote publishers) works exactly the same way as shown in the previous sections. As far as local attendees are concerned, a remote publisher is advertised and looks exactly like any other local publisher. The details about how the remotization works behind the scenes is hidden from them, and not relevant to the subscription process.</p>
<p>Coming to how the requests need to be formatted, the <code>add_remote_publisher</code> must be formatted like the following:</p>
<pre class="fragment">{
        "request" : "add_remote_publisher",
        "room" : &lt;unique ID of the room to add the remote publisher to&gt;,
        "id" : &lt;unique ID to register for the remote publisher; optional, will be chosen by the plugin if missing; doesn't need to be the same as the source one&gt;,
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;",
        "display" : "&lt;display name for the remote publisher; optional&gt;",
        "mcast" : "&lt;multicast group port for receiving RTP packets, if any&gt;",
        "iface" : "&lt;network interface or IP address to bind to, if any (binds to all otherwise)&gt;",
        "port" : &lt;local port for receiving all RTP packets; 0 will bind to a random one (default)&gt;,
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;",
        "streams" : [
                {
                        "type" : "&lt;type of published stream #1 (audio|video|data)"&gt;,
                        "mindex" : "&lt;unique mindex of published stream #1&gt;",
                        "mid" : "&lt;unique mid of of published stream #1&gt;",
                        "disabled" : &lt;if true, it means this stream is currently inactive/disabled (and so codec, description, etc. will be missing)&gt;,
                        "codec" : "&lt;codec used for published stream #1&gt;",
                        "description" : "&lt;text description of published stream #1, if any&gt;",
                        "disabled" : &lt;true if published stream #1 is currently disabled&gt;,
                        "stereo" : &lt;true if published stream #1 is audio and stereo&gt;,
                        "fec" : &lt;true if published stream #1 is audio and uses FEC&gt;,
                        "dtx" : &lt;true if published stream #1 is audio and uses DTX&gt;,
                        "h264-profile" : "&lt;in case H.264 is used by the stream, the negotiated profile&gt;",
                        "vp9-profile" : "&lt;in case VP9 is used by the stream, the negotiated profile&gt;",
                        "simulcast" : &lt;true if published stream #1 is video and uses simulcast&gt;,
                        "svc" : &lt;true if published stream #1 is video and uses SVC (VP9 and AV1 only)&gt;,
                        "audiolevel_ext_id" : &lt;in case the audio level extension is used by this stream, its ID&gt;,
                        "videoorient_ext_id" : &lt;in case the video orientation extension is used by this stream, its ID&gt;,
                        "playoutdelay_ext_id" : &lt;in case the playout delay extension is used by this stream, its ID&gt;
                },
                // Other streams, if any
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;same as request&gt;,
        "id" : &lt;unique ID associated to the new remote publisher&gt;,
        "ip" : "&lt;host address to use to send RTP associated to this remote publisher&gt;",
        "port" : &lt;port to use to send RTP associated to this remote publisher&gt;,
        "rtcp_port" : &lt;port to latch to in order to receive RTCP feedback from this remote publisher&gt;
}
</pre><p>To update a previously created remote publisher, the <code>update_remote_publisher</code> request is used, which must be formatted like the following:</p>
<pre class="fragment">{
        "request" : "update_remote_publisher",
        "room" : &lt;unique ID of the room the remote publisher is in&gt;,
        "id" : &lt;unique ID of the remote publisher&gt;,
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;",
        "display" : "&lt;new display name for the remote publisher; optional&gt;",
        "metadata" : &lt;new valid json object of metadata; optional&gt;,
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;",
        "streams" : [
                {
                        // Same syntax as add_remote_publisher: only needs to
                        // reference new or modified streams, not all of them
                },
                // Other streams, if any
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success"
}
</pre><p>To remove a previously created remote publisher, the <code>remove_remote_publisher</code> request is used, which must be formatted like the following:</p>
<pre class="fragment">{
        "request" : "remove_remote_publisher",
        "room" : &lt;unique ID of the room the remote publisher is in&gt;,
        "id" : &lt;unique ID of the remote publisher&gt;,
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success"
}
</pre><p>Other attendees in the same room as the remote publishers will be notified accordingly, exactly as it happens when a local publisher goes aeay or close their PeerConnection.</p>
<p>For what concerns the source instance (from where the publisher is remotized to a different VideoRoom instance), the <code>publish_remotely</code> request is used, which must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "publish_remotely",
        "room" : &lt;unique ID of the room the local publisher to remotize is in&gt;,
        "publisher_id" : &lt;unique ID of the local publisher to remotize&gt;,
        "remote_id" : "&lt;unique ID to associate to this remotization; this has nothing to do with the ID the publisher will have in the remote instance, and is only used to address this specific remotization on the source instance&gt;",
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;",
        "host" : "&lt;host address to forward the RTP and data packets to&gt;",
        "host_family" : "&lt;ipv4|ipv6, if we need to resolve the host address to an IP; by default, whatever we get&gt;",
        "port" : &lt;port to forward the packets to&gt;,
        "rtcp_port" : &lt;port to contact to receive RTCP feedback from the recipient; optional, and only for RTP streams, not data&gt;,
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;same as request&gt;,
        "id" : &lt;unique ID of the local publisher&gt;,
        "remote_id" : "&lt;unique ID of this remotization (needed for unpublish_remotely)&gt;"
}
</pre><p>Notice that, as explained before, <code>publish_remotely</code> expects a remote publisher ready to receive their media, which is why <code>add_remote_publisher</code> must be sent on the target Janus instance first: the info returned by that request (IP and ports) are what you then feed to <code>publish_remotely</code> .</p>
<p>The <code>publish_remotely</code> request can be used multiple times for the same local publisher, e.g., to make the same publisher available on more than one remote Janus/VideoRoom instance. This is why <code>remote_id</code> is needed to be able to individually address each specific remotization, in case you want to, e.g., stop making a specific publisher available on a specigic Janus instance, but keep it available on others.</p>
<p>To disable a specific remotization of a local publisher, the <code>unpublish_remotely</code> request is used, which must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "unpublish_remotely",
        "room" : &lt;unique ID of the room the local publisher is in&gt;,
        "publisher_id" : &lt;unique ID of the local publisher&gt;,
        "remote_id" : "&lt;unique ID to associate to this remotization of the local publisher&gt;",
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;same as request&gt;,
        "id" : &lt;unique ID of the local publisher&gt;
}
</pre><p>Notice that removing a remotization from the source instance only stops the delivery of RTP packets to the target of the remotization: it does <b>NOT</b> also remove the remote publisher from the remote instance. It's up to you to notify the target instance with <code>remove_remote_publisher</code> .</p>
<p>You can list all the remotizations for a local publisher using <code>list_remotes</code>, which must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list_remotes",
        "room" : &lt;unique ID of the room the local publisher is in&gt;,
        "publisher_id" : &lt;unique ID of the local publisher&gt;,
        "secret" : "&lt;password required to edit the room, mandatory if configured in the room&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "videoroom" : "success",
        "room" : &lt;same as request&gt;,
        "id" : &lt;unique ID of the local publisher&gt;,
        "list" : [
                {
                        "remote_id" : "&lt;unique ID of this remotization of this local publisher"&gt;,
                        "host" : "&lt;address all RTP packets are being sent to"&gt;,
                        "port" : "port all RTP packets are being sent to&gt;
                        "rtcp_port" : "RTCP port, if enabled&gt;
                },
                // Other remotizations, if any
        ]
}
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Tue Jan 14 2025 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2024
</div>
</body>
</html>
