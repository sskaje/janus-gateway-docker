<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JavaScript API</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.9.2/umd/popper.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.2/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.2/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 2001;" src="forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<div class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary">
<div class="container">
	<a class="navbar-brand" href="/">Janus (multistream)</a>
	<button type="button" class="navbar-toggler" data-toggle="collapse" data-target=".navbar-collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="navbar-collapse collapse" id="navbarResponsive">
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="/demos/">Demos</a></li>
			<li class="nav-item"><a class="nav-link active" href="index.html">Documentation</a></li>
			<li class="nav-item"><a class="nav-link" href="/citeus.html">Papers</a></li>
			<li class="nav-item"><a class="nav-link" href="/support.html">Need help?</a></li>
			<li class="nav-item"><a class="nav-link" href="https://janus-legacy.conf.meetecho.com/">Janus (0.x)</a></li>
			<li class="nav-item"><a class="nav-link januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<ul class="navbar-nav ms-auto">
			<li class="nav-item">
				<a class="nav-link meetecho-logo" target="_blank" href="https://www.meetecho.com">
					<img src="meetecho-logo.png"/>
				</a>
			</li>
		</ul>
	</div>
</div>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">JavaScript API</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Janus exposes, assuming the HTTP transport has been compiled, a pseudo-RESTful interface, and optionally also WebSocket/RabbitMQ/MQTT/Nanomsg/UnixSockets interfaces as well, all of which based on JSON messages. These interfaces are described in more detail in the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> <a class="el" href="rest.html#WS">WebSockets Interface</a> <a class="el" href="rest.html#rabbit">RabbitMQ interface</a> <a class="el" href="rest.html#apimqtt">MQTT interface</a> <a class="el" href="rest.html#apinanomsg">Nanomsg interface</a> and <a class="el" href="rest.html#unix">UnixSockets interface</a> documentation respectively, and all allow clients to take advantage of the features provided by Janus and the functionality made available by its plugins. Considering most clients will be web browsers, a common choice will be to rely on either the REST or the WebSockets interface for the purpose. To make things easier for web developers, a JavaScript library (<code>janus.js</code>) is available that can make use of both interfaces using exactly the same API. This library eases the task of creating sessions with the Janus core, attaching WebRTC users to plugins, send and receive requests and events to the plugins themselves and so on. For real examples of how this library can be used, check the demos in the <b>html</b> folder of this package. Notice that the <code>janus.js</code> library makes use of the features made available by the <a href="https://github.com/webrtc/adapter">webrtc-adapter</a> shim, which means that your web application should always include it as a dependency. For instance, all the demos link to it externally via <a href="https://cdnjs.com/">cdnjs.com</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The current <code>janus.js</code> library allows you to provide custom implementations of certain dependencies, in order to make it easier to integrate with other JavaScript libraries and frameworks. Using this feature you can ensure <code>janus.js</code> does not (implicitly) depend on certain global variables. Two implementations are included in <code>janus.js</code> itself:</dd></dl>
<ol type="1">
<li><a class="el" href="js-dependencies.html#js-default-deps">Janus.useDefaultDependencies</a> which relies on native browser APIs, which in turn require somewhat more modern browsers</li>
<li><a class="el" href="js-dependencies.html#js-old-deps">Janus.useOldDependencies</a> which uses jQuery (<a href="http://jquery.com/">http://jquery.com/</a>) instead, and should provide equivalent behaviour to previous versions of <code>janus.js</code> </li>
</ol>
<p>By default <a class="el" href="js-dependencies.html#js-default-deps">Janus.useDefaultDependencies</a> will be used, but you can override this when initialising the Janus library and pass a custom dependencies object instead. For details, refer to: <a class="el" href="js-dependencies.html">Working with custom janus.js dependencies</a></p>
<p>In general, when using the Janus features, you would normally do the following:</p>
<ol type="1">
<li>include the Janus JavaScript library in your web page;</li>
<li>initialize the Janus JavaScript library and (optionally) passing its dependencies;</li>
<li>connect to the server and create a session;</li>
<li>create one or more handles to attach to a plugin (e.g., echo test and/or streaming);</li>
<li>interact with the plugin (sending/receiving messages, negotiating a PeerConnection);</li>
<li>eventually, close all the handles and shutdown the related PeerConnections;</li>
<li>destroy the session.</li>
</ol>
<p>The above steps will be presented in order, describing how you can use the low level API to accomplish them. Consider that in the future we might provide higher level wrappers to this API to address specific needs, e.g., a higher level API for each plugin: this would make it even easier to use the server features, as a high level API for the streaming plugin, for instance, may just ask you to provide the server address and the ID of the <code>&lt;video&gt;</code> element to display the stream in, and would take care of all the above mentioned steps on your behalf. Needless to say, you're very welcome to provide wrapper APIs yourself, if you feel a sudden urge to do so! :-)</p>
<h1><a class="anchor" id="janusjs"></a>
Using janus.js</h1>
<p>As a first step, you should include the Janus library in your project. Depending on your needs you can either use <code>janus.js</code> or one of the generated JavaScript module variants of it. For available module syntaxes and how to build the corresponding variants, see: <a class="el" href="js-modules.html">Using janus.js as JavaScript module</a></p>
<pre class="fragment">&lt;script type="text/javascript" src="janus.js" &gt;&lt;/script&gt;
</pre><p>The core of the JavaScript API is the <code>Janus</code> object. This object needs to be initialized the first time it is used in a page. This can be done using the static <code>init</code> method of the object, which accepts the following options:</p>
<ul>
<li><code>debug:</code> whether debug should be enabled on the JavaScript console, and what levels<ul>
<li><code>true</code> or <code>"all"</code>: all debuggers enabled (Janus.trace, Janus.debug, Janus.log, Janus.warn, Janus.error)</li>
<li>array (e.g., <code>["trace", "warn"]</code>): only enable selected debuggers (allowed tokens: trace, debug, log, warn, error)</li>
<li><code>false:</code> disable all debuggers</li>
</ul>
</li>
<li><code>callback:</code> a user provided function that is invoked when the initialization is complete</li>
<li><code>dependencies:</code> a user provided implementation of Janus library dependencies</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">Janus.init({
   debug: true,
   dependencies: Janus.useDefaultDependencies(), // or: Janus.useOldDependencies() to get the behaviour of previous Janus versions
   callback: function() {
           // Done!
   }
});</pre><dl class="section note"><dt>Note</dt><dd>When using one of the JavaScript module variants of <code>janus.js</code>, you will need to import the <code>Janus</code> symbol from the module first. See also: <a class="el" href="js-modules.html">Using janus.js as JavaScript module</a> For example, using the ECMAScript module variant, the above example should be altered to:</dd></dl>
<pre class="fragment">import * as Janus from './janus.es.js'

Janus.init({
   debug: true,
   dependencies: Janus.useDefaultDependencies(), // or: Janus.useOldDependencies() to get the behaviour of previous Janus versions
   callback: function() {
           // Done!
   }
});</pre><p>Once the library has been initialized, you can start creating sessions. Normally, each browser tab will need a single session with the server: in fact, each Janus session can contain several different plugin handles at the same time, meaning you can start several different WebRTC sessions with the same or different plugins for the same user using the same Janus session. That said, you're free to set up different Janus sessions in the same page, should you prefer so.</p>
<p>Creating a session is quite easy. You just need to use the <code>new</code> constructor to create a new <code>Janus</code> object that will handle your interaction with the server. Considering the dynamic and asynchronous nature of Janus sessions (events may occur at any time), there are several properties and callbacks you can configure when creating a session:</p>
<ul>
<li><code>server:</code> the address of the server as a specific address (e.g., <a href="http://yourserver:8088/janus">http://yourserver:8088/janus</a> to use the plain HTTP API or ws://yourserver:8188/ for WebSockets) or as an array of addresses to try sequentially to allow automatic for fallback/failover during setup;</li>
<li><code>iceServers:</code> a list of STUN/TURN servers to use (a default STUN server will be used if you skip this property);</li>
<li><code>withCredentials:</code> whether the <code>withCredentials</code> property of XHR requests should be enabled or not (false by default, and only valid when using HTTP as a transport, ignored for WebSockets);</li>
<li><code>max_poll_events:</code> the number of events that should be returned when polling; the default is 1 (polling returns an object), passing a higher number will have the backend return an array of objects instead (again, only valid for HTTP usage as this is strictly related to long polling, ignored for WebSockets);</li>
<li><code>destroyOnUnload:</code> whether we should destroy automatically try and destroy this session via Janus API when <code>onbeforeunload</code> is called (true by default);</li>
<li><code>token</code> , <code>apisecret:</code> optional parameters only needed in case you're <a class="el" href="auth.html">Authenticating the Janus API</a> ;</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the session was successfully created and is ready to be used;</li>
<li><code>error:</code> the session was NOT successfully created;</li>
<li><code>destroyed:</code> the session was destroyed and can't be used any more.</li>
</ul>
</li>
</ul>
<p>These properties and callbacks are passed to the method as properties of a single parameter object: that is, the <code>Janus</code> constructor takes a single parameter, which although acts as a container for all the available options. The <code>success</code> callback is where you typically start your application logic, e.g., attaching the peer to a plugin and start a media session.</p>
<p>Here's an example:</p>
<pre class="fragment">var janus = new Janus(
    {
        server: 'http://yourserver:8088/janus',
        success: function() {
            // Done! attach to plugin XYZ
        },
        error: function(cause) {
            // Error, can't go on...
        },
        destroyed: function() {
            // I should get rid of this
        }
    });</pre><p>As anticipated, the server may be a specific address, e.g.:</p>
<pre class="fragment">var janus = new Janus(
    {
        server: 'http://yourserver:8088/janus',
                // or
        server: 'ws://yourserver:8188/',
        [..]</pre><p>or an array of addresses. Such an array can be especially useful if you want the library to first check if the WebSockets server is reachable and, if not, fallback to plain HTTP, or just to provide a link multiple instances to try for failover. This is an example of how to pass a 'try websockets and fallback to HTTP' array:</p>
<pre class="fragment">var janus = new Janus(
    {
        server: ['ws://yourserver:8188/','http://yourserver:8088/janus'],
        [..]</pre><p>Once created, this object represents your session with the server. you can interact with a <code>Janus</code> object in several different ways. In particular, the following properties and methods are defined:</p>
<ul>
<li><code>getServer()</code>: returns the address of the server;</li>
<li><code>isConnected()</code>: returns <code>true</code> if the Janus instance is connected to the server, <code>false</code> otherwise;</li>
<li><code>getSessionId()</code>: returns the unique Janus session identifier;</li>
<li><code>attach(parameters)</code>: attaches the session to a plugin, creating a handle; more handles to the same or different plugins can be created at the same time;</li>
<li><code>destroy(parameters)</code>: destroys the session with the server, and closes all the handles (and related PeerConnections) the session may have with any plugin as well.</li>
</ul>
<p>The most important property is obviously the <code>attach()</code> method, as it's what will allow you to exploit the features of a plugin to manipulate the media sent and/or received by a PeerConnection in your web page. This method will create a plugin handle you can use for the purpose, for which you can configure properties and callbacks when calling the <code>attach()</code> method itself. As for the <code>Janus</code> constructor, the <code>attach()</code> method takes a single parameter that can contain any of the following properties and callbacks:</p>
<ul>
<li><code>plugin:</code> the unique package name of the plugin (e.g., <code>janus.plugin.echotest</code> );</li>
<li><code>opaqueId:</code> an optional opaque string meaningful to your application (e.g., to map all the handles of the same user);</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the handle was successfully created and is ready to be used;</li>
<li><code>error:</code> the handle was NOT successfully created;</li>
<li><code>consentDialog:</code> this callback is triggered just before <code>getUserMedia</code> is called (parameter=<b>true</b>) and after it is completed (parameter=<b>false</b>); this means it can be used to modify the UI accordingly, e.g., to prompt the user about the need to accept the device access consent requests;</li>
<li><code>webrtcState:</code> this callback is triggered with a <b>true</b> value when the PeerConnection associated to a handle becomes active (so ICE, DTLS and everything else succeeded) from the Janus perspective, while <b>false</b> is triggered when the PeerConnection goes down instead; useful to figure out when WebRTC is actually up and running between you and Janus (e.g., to notify a user they're actually now active in a conference); notice that in case of <b>false</b> a reason string may be present as an optional parameter;</li>
<li><code>connectionState:</code> this callback is triggered when the connection state for the PeerConnection associated to the handle changes: the argument of the callback is the new state as a string (e.g., "connected" or "failed");</li>
<li><code>iceState:</code> this callback is triggered when the ICE state for the PeerConnection associated to the handle changes: the argument of the callback is the new state as a string (e.g., "connected" or "failed");</li>
<li><code>mediaState:</code> this callback is triggered when Janus starts or stops receiving your media: for instance, a <code>mediaState</code> with mid=<b>0</b>, type=<b>audio</b> and on=<b>true</b> means Janus started receiving the audio stream identified by mid <code>b</code> in the offer/answer exchange and transceivers (or started getting them again after a pause of more than a second); a <code>mediaState</code> with type=<b>video</b> and on=<b>false</b> means Janus hasn't received any video from you in the last second, after a start was detected before; useful to figure out when Janus actually started handling your media, or to detect problems on the media path (e.g., media never started, or stopped at some time);</li>
<li><code>slowLink:</code> this callback is triggered when Janus reports trouble either sending or receiving media on the specified PeerConnection, typically as a consequence of too lost packets detected to/from the user in the last second: for instance, a <code>slowLink</code> with uplink=<b>true</b> means you notified several missing packets from Janus, while uplink=<b>false</b> means Janus is not receiving all your packets; useful to figure out when there are problems on the media path (e.g., excessive loss), in order to possibly react accordingly (e.g., decrease the bitrate if most of our packets are getting lost);</li>
<li><code>onmessage:</code> a message/event has been received from the plugin;</li>
<li><code>onlocaltrack:</code> a local <code>MediaStreamTrack</code> is available and ready to be displayed;</li>
<li><code>onremotetrack:</code> a remote <code>MediaStreamTrack</code> is available and ready to be displayed;</li>
<li><code>ondataopen:</code> a Data Channel is available and ready to be used;</li>
<li><code>ondata:</code> data has been received through the Data Channel;</li>
<li><code>oncleanup:</code> the WebRTC PeerConnection with the plugin was closed;</li>
<li><code>detached:</code> the plugin handle has been detached by the plugin itself, and so should not be used anymore.</li>
</ul>
</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">// Attach to echo test plugin, using the previously created janus instance
janus.attach(
    {
        plugin: "janus.plugin.echotest",
        success: function(pluginHandle) {
            // Plugin attached! 'pluginHandle' is our handle
        },
        error: function(cause) {
            // Couldn't attach to the plugin
        },
        consentDialog: function(on) {
            // e.g., Darken the screen if on=true (getUserMedia incoming), restore it otherwise
        },
        onmessage: function(msg, jsep) {
            // We got a message/event (msg) from the plugin
            // If jsep is not null, this involves a WebRTC negotiation
        },
        onlocaltrack: function(track, added) {
            // A local track to display has just been added (getUserMedia worked!) or removed
        },
        onremotetrack: function(track, mid, added, metadata) {
            // A remote track (working PeerConnection!) with a specific mid has just been added or removed
            // You can query metadata to get some more information on why track was added or removed
            // metadata fields:
            //   - reason: 'created' | 'ended' | 'mute' | 'unmute'
        },
        oncleanup: function() {
            // PeerConnection with the plugin closed, clean the UI
            // The plugin handle is still valid so we can create a new one
        },
        detached: function() {
            // Connection with the plugin closed, get rid of its features
            // The plugin handle is not valid anymore
        }
    });</pre><p>So the <code>attach()</code> method allows you to attach to a plugin, and specify the callbacks to invoke when anything relevant happens in this interaction. To actively interact with the plugin, you can use the <code>Handle</code> object that is returned by the <code>success</code> callback (pluginHandle in the example).</p>
<p>This <code>Handle</code> object has several methods you can use to interact with the plugin or check the state of the session handle:</p>
<ul>
<li><code>getId()</code>: returns the unique handle identifier;</li>
<li><code>getPlugin()</code>: returns the unique package name of the attached plugin;</li>
<li><code>send(parameters)</code>: sends a message (with or without a jsep to negotiate a PeerConnection) to the plugin;</li>
<li><code>createOffer(callbacks)</code>: asks the library to create a WebRTC compliant OFFER;</li>
<li><code>createAnswer(callbacks)</code>: asks the library to create a WebRTC compliant ANSWER;</li>
<li><code>handleRemoteJsep(callbacks)</code>: asks the library to handle an incoming WebRTC compliant session description;</li>
<li><code>replaceTracks(tracks, callbacks)</code>: asks the library to replace local tracks without renegotiating (no other offer/answer);</li>
<li><code>dtmf(parameters)</code>: sends a DTMF tone on the PeerConnection;</li>
<li><code>data(parameters)</code>: sends data through the Data Channel, if available;</li>
<li><code>getBitrate(mid)</code>: gets a verbose description of the currently received video stream bitrate (optional mid to specify the stream, first video stream if missing);</li>
<li><code>getLocalTracks()</code>: returns an array of the tracks that are currently being sent on this PeerConnection, as basic objects including, e.g., type, <code>mid</code> and <code>label</code> of the track;</li>
<li><code>getRemoteTracks()</code>: returns an array of the tracks that are currently being received on this PeerConnection, as basic objects including, e.g., type, <code>mid</code> and <code>label</code> of the track;</li>
<li><code>muteAudio</code> , <code>unmuteAudio</code> , <code>isAudioMuted</code> , <code>muteVideo</code> , <code>unmuteVideo</code> , <code>isVideoMuted:</code> a set of helper functions to mute, unmute or check the muted status of a specific audio or video track that is currently being sent (optional mid to specify the stream, first audio/video stream if missing);</li>
<li><code>getLocalVolume</code> , <code>getRemoteVolume:</code> a couple of helper functions to get the current volume of the local or remote track; notice that this isn't supported on Firefox at the moment (optional mid to specify the stream, first audio stream if missing);</li>
<li><code>hangup(sendRequest)</code>: tells the library to close the PeerConnection; if the optional <code>sendRequest</code> argument is set to <code>true</code>, then a <code>hangup</code> Janus API request is sent to Janus as well (disabled by default, Janus can usually figure this out via DTLS alerts and the like but it may be useful to enable it sometimes);</li>
<li><code>detach(parameters)</code>: detaches from the plugin and destroys the handle, tearing down the related PeerConnection if it exists.</li>
</ul>
<p>While the <code>Handle</code> API may look complex, it's actually quite straightforward once you get the concept. The only step that may require a little more effort to understand is the PeerConnection negotiation, but again, if you're familiar with the WebRTC API, the <code>Handle</code> actually makes it a lot easier.</p>
<p>The idea behind it's usage is the following:</p>
<ol type="1">
<li>you use <code>attach()</code> to create a <code>Handle</code> object;</li>
<li>in the <code>success</code> callback, your application logic can kick in: you may want to send a message to the plugin (<code>send({msg})</code>), negotiate a PeerConnection with the plugin right away ( <code>createOffer</code> followed by a <code>send({msg, jsep})</code>) or wait for something to happen to do anything;</li>
<li>the <code>onmessage</code> callback tells you when you've got messages from the plugin; if the <code>jsep</code> parameter is not null, just pass it to the library, which will take care of it for you; if it's an <b>OFFER</b> use <code>createAnswer</code> (followed by a <code>send({msg, jsep})</code> to close the loop with the plugin), otherwise use <code>handleRemoteJsep</code> ;</li>
<li>whether you took the initiative to set up a PeerConnection or the plugin did, the <code>onlocaltrack</code> and/or the <code>onremotetrack</code> callbacks will provide you with info on media tracks you can display or play in your page;</li>
<li>each plugin may allow you to manipulate what should flow through the PeerConnection channel: the <code>send</code> method and <code>onmessage</code> callback will allow you to handle this interaction (e.g., to tell the plugin to mute your stream, or to be notified about someone joining a virtual room), while the <code>ondata</code> callback is triggered whenever data is received on the Data Channel, if available (and the <code>ondataopen</code> callback will tell you when a Data Channel is actually available).</li>
</ol>
<p>The following paragraphs will delve a bit deeper in the negotiation mechanism provided by the <code>Handle</code> API, in particular describing the properties and callbacks that may be involved. To follow the approach outlined by the W3C WebRTC API, this negotiation mechanism is heavily based on asynchronous methods as well. Notice that the following paragraphs address the first negotiation step, that is the one to create a new PeerConnection from scratch: to know how to originate or handle a renegotiation instead (e.g., to add/remove/replace a media source, or force an ICE restart) check the <a class="el" href="JS.html#renegotiation">Updating an existing PeerConnection (with or without renegotiations)</a> section instead.</p>
<ul>
<li><code>createOffer</code> takes a single parameter, that can contain any of the following properties and callbacks:<ul>
<li><code>tracks:</code> you can use this property to tell the library which media (audio/video/data) you're interested in, and whether you're going to send and/or receive any of them; by default no device is captured, and Data Channels are disabled as well; incoming audio and video is instead autoaccepted unless you tell the library otherwise; the same property can also be used to update sessions (e.g., to add/remove/replace tracks); this option is an array of objects, where each object can take any of the following properties:<ul>
<li><code>type:</code> mandatory, must be one of "audio", "video", "screen" and "data";</li>
<li><code>mid:</code> to address existing tracks (e.g., when answering or updating sessions), the <code>mid</code> property specifies that the info in the related track object are specific to that target; notice that this is ignored in a first <code>createOffer</code> , as mid values are created by the browser automatically and cannot be forced;</li>
<li><code>capture:</code> in case something must be captured (e.g., a microphone for "audio" or a "webcam" for video), the <code>capture</code> property can be used to dictate what and how; passing <code>true</code> asks for the default device, but <code>getUserMedia</code> (for audio/video) or <code>getDisplayMedia</code> (for screen sharing) constraints can be passed as well as objects, and in case those will be used instead; passing a <code>MediaStreamTrack</code> instance will tell the library not to capture anything, but use the provided track as a source instead;</li>
<li><code>simulcast:</code> <code>true/false</code>, for video, whether simulcast should be used for this track;</li>
<li><code>svc:</code> for video, the scalability mode to enable, in case SVC needs to be used for this track; notice that SVC support is experimental in Janus, and not fully supported in all browsers either;</li>
<li><code>recv:</code> <code>true/false</code> , whether audio or video should be received as well; in case <code>capture</code> is set but <code>recv</code> is false, then this means you're asking for a "sendonly" track;</li>
<li><code>add:</code> <code>true/false</code> , whether a new track should be added (default is true for offers);</li>
<li><code>replace:</code> <code>true/false</code> , whether a provided <code>capture</code> should replace what is being captured for the specified track;</li>
<li><code>remove:</code> <code>true/false</code> , whether the local track that's currently captured should be removed, meaning nothing will be sent for that specific stream;</li>
<li><code>dontStop:</code> <code>true/false</code> , whether a track that is being added right now should <b>NOT</b> be stopped when the track is removed; this is helpful whenever, for instance, an external track is being provided to <code>capture</code> , and the application wants to keep control on the life cycle of the <code>MediaStreamTrack</code> instance;</li>
<li><code>transforms:</code> in case Insertable Streams need to be used (e.g., for end-to-end encryption), the <code>sender</code> and/or <code>receiver</code> transform functions for this track can be provided in the <code>transforms</code> property;</li>
</ul>
</li>
<li><code>trickle:</code> <code>true/false</code>, to tell the library whether you want Trickle ICE to be used (true, the default) or not (false);</li>
<li>a set of callbacks to be notified about the result, namely:<ul>
<li><code>success:</code> the session description was created (attached as a parameter) and is ready to be sent to the plugin;</li>
<li><code>error:</code> the session description was NOT successfully created;</li>
<li><code>customizeSdp:</code> you can modify the sdp generated by the webrtc engine if you need;</li>
</ul>
</li>
</ul>
</li>
<li><code>createAnswer</code> takes the same options as createOffer, but requires an additional one as part of the single parameter argument:<ul>
<li><code>jsep:</code> the session description sent by the plugin (e.g., as received in an <code>onmessage</code> callback) as its OFFER.</li>
</ul>
</li>
</ul>
<p>Whether you use <code>createOffer</code> or <code>createAnswer</code> depending on the scenario, you should end up with a valid <code>jsep</code> object returned in the <code>success</code> callback. You can attach this <code>jsep</code> object to a message in a <code>send</code> request to pass it to the plugin, and have Janus negotiate a PeerConnection with your application.</p>
<p>Here's an example of how to use <code>createOffer</code>, taken from the Echo Test demo page:</p>
<pre class="fragment">// Attach to echo test plugin
janus.attach(
    {
        plugin: "janus.plugin.echotest",
        success: function(pluginHandle) {
            // Negotiate WebRTC
            echotest = pluginHandle;
            echotest.createOffer(
                {
                    // We want bidirectional audio and video, plus data channels
                    tracks: [
                        { type: 'audio', capture: true, recv: true },
                        { type: 'video', capture: true, recv: true },
                        { type: 'data' },
                    ],
                    success: function(jsep) {
                        // Got our SDP! Send our OFFER to the plugin
                        echotest.send({ message: body, jsep: jsep });
                    },
                    error: function(error) {
                        // An error occurred...
                    },
                    customizeSdp: function(jsep) {
                        // if you want to modify the original sdp, do as the following
                        // oldSdp = jsep.sdp;
                        // jsep.sdp = yourNewSdp;
                    }
                });
        },
        [..]
        onmessage: function(msg, jsep) {
            // Handle msg, if needed, and check jsep
            if(jsep) {
                // We have the ANSWER from the plugin
                echotest.handleRemoteJsep({jsep: jsep});
            }
        },
        [..]
        onlocaltrack: function(track, added) {
            // Invoked after createOffer
            // This is info on a local track: when added, we can choose to render
        },
        onremotetrack: function(track, mid, added, metadata) {
            // Invoked after handleRemoteJsep has got us a PeerConnection
            // This is info on a remote track: when added, we can choose to render
            // You can query metadata to get some more information on why track was added or removed
            // metadata fields:
            //   - reason: 'created' | 'ended' | 'mute' | 'unmute'
        },
        [..]</pre><p>This, instead, is an example of how to use <code>createAnswer</code>, taken from the Streaming demo page:</p>
<pre class="fragment">// Attach to the Streaming plugin
janus.attach(
    {
        plugin: "janus.plugin.streaming",
        success: function(pluginHandle) {
            // Handle created
            streaming = pluginHandle;
            [..]
        },
        [..]
        onmessage: function(msg, jsep) {
            // Handle msg, if needed, and check jsep
            if(jsep) {
                // We have an OFFER from the plugin
                streaming.createAnswer(
                    {
                        // We attach the remote OFFER
                        jsep: jsep,
                        // We only specify data channels here, as this way in
                        // case they were offered we'll enable them. Since we
                        // don't mention audio or video tracks, we autoaccept them
                        // as recvonly (since we won't capture anything ourselves)
                        tracks: [
                            { type: 'data' }
                        ],
                        success: function(ourjsep) {
                            // Got our SDP! Send our ANSWER to the plugin
                            var body = { request: "start" };
                            streaming.send({ message: body, jsep: ourjsep });
                        },
                        error: function(error) {
                            // An error occurred...
                        }
                    });
            }
        },
        [..]
        onlocaltrack: function(track, added) {
            // This will NOT be invoked, we chose recvonly
        },
        onremotetrack: function(track, mid, added, metadata) {
            // Invoked after send has got us a PeerConnection
            // This is info on a remote track: when added, we can choose to render
            // This is info on a remote track: when added, we can choose to render
            // You can query metadata to get some more information on why track was added or removed
            // metadata fields:
            //   - reason: 'created' | 'ended' | 'mute' | 'unmute'
        },
        [..]</pre><p>Of course, these are just a couple of examples where the scenarios assumed that one plugin would only receive (Echo Test) or generate (Streaming) offers. A more complex example (e.g., a call using the Video Call, SIP or NoSIP plugin, or a videoconfecence using the Video Room) would involve both, allowing you to either send offers to a plugin, or receive some from them. Handling this is just a matter of checking the <code>type</code> of the <code>jsep</code> object and reacting accordingly.</p>
<h1><a class="anchor" id="renegotiation"></a>
Updating an existing PeerConnection (with or without renegotiations)</h1>
<p>While the JavaScript APIs described above will suffice for most of the common scenarios, there are cases when updates on a PeerConnection may be needed. This can happen whenever, for instance, you want to add a new media source (e.g., add video to an audio only call), replace an existing one (e.g., switch from capturing the camera to sharing your screen), or trigger an ICE restart because of a network change. While adding or removing tracks requires a renegotiation, which means a new SDP offer/answer round to update the existing PeerConnection, just replacing a track can be done without any further SDP exchange. In both cases, the <code>tracks</code> property introduced before can be used to update a session.</p>
<p>To just replace an existing track (e.g., changing the camera used to capture the video we're sending) the <code>replaceTracks</code> handle method can be used. Using it is quite trivial, since you simply need to provide a list of tracks you want to update, identify them somehow (e.g., via their <code>mid</code> ), and provide the new <code>capture</code> property. A simple example that shows how to replace a video track with a specific camera identified by its <code>deviceId</code> is the following:</p>
<pre class="fragment">echotest.replaceTracks({
    tracks: [
        {
            type: 'video',
            mid: '1',    // We assume mid 1 is video
            capture: { deviceId: { exact: videoDeviceId } }
        }
    ]
});</pre><p>In case a new track needs to be added to a session, or an existing track be removed, instead, a renegotiation is indeed needed, because it requires changes to be signalled to the other party. In that case, a renegotiation happens exactly as new sessions do, meaning that you either perform a new <code>createOffer</code> followed by a <code>handleRemoteJsep</code> with the updated answer, or you handle an incoming updated offer and provide an updated answer via <code>createAnswer</code> : the library will automatically understand from context if you're creating a new session or updating an existing one.</p>
<p>When updating a session to add or remove tracks, you need to provide an updated <code>tracks</code> property as well. It's important to only include in this <code>tracks</code> property a list of tracks you want to change: omitting existing tracks will result in the library not making any change to them. This means that a <code>createOffer</code> without a <code>tracks</code> property, for instance, will simply generate a new offer without applying any change (which, as we'll see later, can be useful in some cases, e.g., ICE restarts).</p>
<p>Depending on what you want to update, you'll need to set one of the following properties to <code>true</code> in the related track object:</p>
<ul>
<li><code>add:</code> adds a new track to the session;</li>
<li><code>replace:</code> replaces an existing track in the session (similar to what <code>replaceTracks</code> does, but within the context of a renegotiation);</li>
<li><code>remove:</code> removes an existing track from a session (the direction of the related m-line will be changed to either "recvonly" or "inactive", depending on whether there's incoming media as well or not).</li>
</ul>
<p>Notice that these properties are only processed when you're trying a renegotiation, and will be ignored when creating a new PeerConnection. These properties don't replace the existing <code>track</code> properties, but go along with them. For instance, when adding a new video stream, or replacing an existing one, you can still use the video related properties as before, e.g., to pass a specific device ID or asking for a screenshare instead of a camera. As anticipated, omitting info on existing tracks will leave them untouched.</p>
<p>It's important to point out that, as for negotiations that result in the creation of a new PeerConnection in the first place, how to perform a renegotiation in practice will typically vary depending on the plugin that you're trying to do it for. Some plugins may allow you to offer a renegotiation, others may require you to send a different request instead in order to trigger a renegotiation from the plugin. As it will be clearer later, this is especially true for ICE restarts. As such, apart from the generic and core-related definitions introduced in this section, please refer to the documentation for each individual plugin for more information about how to perform renegotiations in specific use cases.</p>
<p>Here's a simple example of how you can remove the local video capture in a session, e.g., in the EchoTest demo:</p>
<pre class="fragment">// Remove local video
echotest.createOffer(
    {
        tracks: [{ type: 'video', mid: '1', remove: true }],
        success: function(jsep) {
            echotest.send({ message: { video: true }, jsep: jsep })
        },
        error: function(error) {
            bootbox.alert('WebRTC error... ' + error.message);
        }
    });</pre><p>This other example shows how you can add a new video stream, e.g., a screen share, to an existing PeerConnection instead:</p>
<pre class="fragment">// Add local video
echotest.createOffer(
    {
        tracks: [{ type: 'screen', add: true, capture: true }],
        success: function(jsep) {
            echotest.send({ message: { video: true }, jsep: jsep })
        },
        error: function(error) {
            bootbox.alert('WebRTC error... ' + error.message);
        }
    });</pre><p>Notice that renegotiations involving media changes (both local and remote) will likely result in new calls to the <code>onlocaltrack</code> and <code>onremotetrack</code> application callbacks: as such, be prepared to see those callbacks called for the same PeerConnection more than once during the course of a media session.</p>
<h1><a class="anchor" id="restarts"></a>
ICE restarts</h1>
<p>While ICE restarts can be achieved with a renegotiation, they're complex enough to deserve a specific subsection. In fact, ICE restarts don't address changes in the media, but in the underlying transport itself. They're used, for instance, when there's a network change (e.g., the IP address changed, or the user switched from WiFi to 4G). In order for this to work, new candidates must be exchanged, and connectivity checks must be restarted in order to find the new optimal path.</p>
<p>With <code>janus.js</code>, you can only force an ICE restart when sending a new offer. In order to do so, all you need to do is add <code>iceRestart :true</code> to your <code>createOffer</code> call, and an ICE restart will be requested. The following example shows how this can be done with the EchoTest:</p>
<pre class="fragment">echotest.createOffer(
    {
        iceRestart: true,
        success: function(jsep) {
            echotest.send({ message: { audio: true, video: true }, jsep: jsep});
        }
    });</pre><p>Notice how, in this particular example, we're not asking for any change on the media streams, but just an ICE restart, which is why we don't provide a <code>tracks</code> property at all: as a consequence, the library won't make any changes to the existing streams, but only generate a new offer. If successful, as soon as the answer is received, the client and Janus will restart the ICE process and find a new path for the media packets.</p>
<p>Notice that, with Janus and its plugins, you won't always be able to force an ICE restart by sending a new SDP offer yourself: some plugins, like the Streaming plugin for instance, will want to always send an offer themselves, which means they'll be the ones actually forcing the ICE restart from a negotiation perspective. In order to still allow users to actually originate the process, all the stock Janus plugins that assume they'll be sending offers for some or all of their media streams also expose APIs to force an ICE restart from the server side. You can learn more about this on a plugin level basis <a href="https://github.com/meetecho/janus-gateway/pull/753" target="_blank">here</a> and <a href="https://github.com/meetecho/janus-gateway/pull/1099" target="_blank">here</a>. Besides, make sure you read the documentation for each of the plugins you're interested in using ICE restarts for, as the details for how to perform it properly are typically provided there.</p>
<hr  />
<p>This is it! For more information about the API, have a look at the demo pages that are available in the <b>html</b> folder in this package. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Tue Jan 14 2025 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2024
</div>
</body>
</html>
