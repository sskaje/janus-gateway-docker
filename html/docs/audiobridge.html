<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AudioBridge plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.9.2/umd/popper.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.2/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.2/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 2001;" src="forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<div class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary">
<div class="container">
	<a class="navbar-brand" href="/">Janus (multistream)</a>
	<button type="button" class="navbar-toggler" data-toggle="collapse" data-target=".navbar-collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="navbar-collapse collapse" id="navbarResponsive">
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="/demos/">Demos</a></li>
			<li class="nav-item"><a class="nav-link active" href="index.html">Documentation</a></li>
			<li class="nav-item"><a class="nav-link" href="/citeus.html">Papers</a></li>
			<li class="nav-item"><a class="nav-link" href="/support.html">Need help?</a></li>
			<li class="nav-item"><a class="nav-link" href="https://janus-legacy.conf.meetecho.com/">Janus (0.x)</a></li>
			<li class="nav-item"><a class="nav-link januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<ul class="navbar-nav ms-auto">
			<li class="nav-item">
				<a class="nav-link meetecho-logo" target="_blank" href="https://www.meetecho.com">
					<img src="meetecho-logo.png"/>
				</a>
			</li>
		</ul>
	</div>
</div>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">AudioBridge plugin documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a plugin implementing an audio conference bridge for Janus, specifically mixing Opus streams. This means that it replies by providing in the SDP only support for Opus, and disabling video. Opus encoding and decoding is implemented using libopus (<a href="http://opus.codec.org">http://opus.codec.org</a>). The plugin provides an API to allow peers to join and leave conference rooms. Peers can then mute/unmute themselves by sending specific messages to the plugin: any way a peer mutes/unmutes, an event is triggered to the other participants, so that it can be rendered in the UI accordingly.</p>
<p>Rooms to make available are listed in the plugin configuration file. A pre-filled configuration file is provided in <code>conf/janus.plugin.audiobridge.jcfg</code> and includes a demo room for testing.</p>
<p>To add more rooms or modify the existing one, you can use the following syntax:</p>
<pre class="fragment">room-&lt;unique room ID&gt;: {
        description = This is my awesome room
        is_private = true|false (private rooms don't appear when you do a 'list' request)
        secret = &lt;optional password needed for manipulating (e.g. destroying) the room&gt;
        pin = &lt;optional password needed for joining the room&gt;
        sampling_rate = &lt;sampling rate&gt; (e.g., 16000 for wideband mixing)
        spatial_audio = true|false (if true, the mix will be stereo to spatially place users, default=false)
        audiolevel_ext = true|false (whether the ssrc-audio-level RTP extension must be
                negotiated/used or not for new joins, default=true)
        audiolevel_event = true|false (whether to emit event to other users or not, default=false)
        audio_active_packets = 100 (number of packets with audio level, default=100, 2 seconds)
        audio_level_average = 25 (average value of audio level, 127=muted, 0='too loud', default=25)
        default_expectedloss = percent of packets we expect participants may miss, to help with outgoing FEC (default=0, max=20; automatically used for forwarders too)
        default_bitrate = default bitrate in bps to use for the all participants (default=0, which means libopus decides; automatically used for forwarders too)
        denoise = true|false (whether denoising via RNNoise should be performed for each participant by default)
        record = true|false (whether this room should be recorded, default=false)
        record_file = /path/to/recording.wav (where to save the recording)
        record_dir = /path/to/ (path to save the recording to, makes record_file a relative path if provided)
        mjrs = true|false (whether all participants in the room should be individually recorded to mjr files, default=false)
        mjrs_dir = "/path/to/" (path to save the mjr files to)
        allow_rtp_participants = true|false (whether participants should be allowed to join
                via plain RTP as well, rather than just WebRTC, default=false)
        groups = optional, non-hierarchical, array of groups to tag participants, for external forwarding purposes only

                [The following lines are only needed if you want the mixed audio
                to be automatically forwarded via plain RTP to an external component
                (e.g., an ffmpeg script, or a gstreamer pipeline) for processing.
                By default plain RTP is used, SRTP must be configured if needed]
        rtp_forward_id = numeric RTP forwarder ID for referencing it via API (optional: random ID used if missing)
        rtp_forward_host = host address to forward RTP packets of mixed audio to
        rtp_forward_host_family = ipv4|ipv6; by default, first family returned by DNS request
        rtp_forward_port = port to forward RTP packets of mixed audio to
        rtp_forward_ssrc = SSRC to use to use when streaming (optional: stream_id used if missing)
        rtp_forward_codec = opus (default), pcma (A-Law) or pcmu (mu-Law)
        rtp_forward_ptype = payload type to use when streaming (optional: only read for Opus, 100 used if missing)
        rtp_forward_group = group of participants to forward, if enabled in the room (optional: forwards full mix if missing)
        rtp_forward_srtp_suite = length of authentication tag, if SRTP is needed (32 or 80)
        rtp_forward_srtp_crypto = key to use as crypto, if SRTP is needed (base64 encoded key as in SDES)
        rtp_forward_always_on = true|false, whether silence should be forwarded when the room is empty (optional: false used if missing)
}
</pre><h1><a class="anchor" id="bridgeapi"></a>
Audio Bridge API</h1>
<p>The Audio Bridge API supports several requests, some of which are synchronous and some asynchronous. There are some situations, though, (invalid JSON, invalid request) which will always result in a synchronous error response even for asynchronous requests.</p>
<p><code>create</code>, <code>edit</code>, <code>destroy</code>, <code>exists</code>, <code>allowed</code>, <code>kick</code>, <code>list</code>, <code>mute</code>, <code>unmute</code>, <code>mute_room</code>, <code>unmute_room</code>, <code>listparticipants</code>, <code>listannouncements</code>, <code>resetdecoder</code>, <code>rtp_forward</code>, <code>stop_rtp_forward</code>, <code>list_forwarders</code>, <code>play_file</code>, <code>is_playing</code>, <code>stop_file</code> and <code>stop_all_files</code> are synchronous requests, which means you'll get a response directly within the context of the transaction. <code>create</code> allows you to create a new audio conference bridge dynamically, as an alternative to using the configuration file; <code>edit</code> allows you to dynamically edit some room properties (e.g., the PIN); <code>destroy</code> removes an audio conference bridge and destroys it, kicking all the users out as part of the process; <code>exists</code> allows you to check whether a specific audio conference exists; <code>allowed</code> allows you to edit who's allowed to join a room via ad-hoc tokens; <code>list</code> lists all the available rooms, while <code>listparticipants</code> lists all the participants of a specific room and their details; <code>listannouncements</code> lists all playing announcements of a specific room and their details; <code>resetdecoder</code> marks the Opus decoder for the participant as invalid, and forces it to be recreated (which might be needed if the audio for generated by the participant becomes garbled); <code>rtp_forward</code> allows you to forward the mix of an AudioBridge room via RTP to a separate component (e.g., for broadcasting it to a wider audience, or for processing/recording), whereas <code>stop_rtp_forward</code> can remove an existing forwarder; a list of configured forwarders for a room can be retrieved using the <code>list_forwarders</code> request; finally, <code>play_file</code> allows you to reproduce an audio .opus file in a mix (e.g., to play an announcement or some background music), <code>is_playing</code> checks if a specific file is still playing, while <code>stop_file</code> will stop such a playback instead and <code>stop_all_files</code> will stop all announcements.</p>
<p>The <code>join</code> , <code>configure</code> , <code>changeroom</code> and <code>leave</code> requests instead are all asynchronous, which means you'll get a notification about their success or failure in an event. <code>join</code> allows you to join a specific audio conference bridge; <code>configure</code> can be used to modify some of the participation settings (e.g., mute/unmute); <code>changeroom</code> can be used to leave the current room and move to a different one without having to tear down the PeerConnection and recreate it again (useful for sidebars and "waiting rooms"); finally, <code>leave</code> allows you to leave an audio conference bridge for good.</p>
<p>The AudioBridge plugin also allows you to forward the mix to an external listener, e.g., a gstreamer/ffmpeg pipeline waiting to process the mixer audio stream. You can add new RTP forwarders with the <code>rtp_forward</code> request; a <code>stop_rtp_forward</code> request removes an existing RTP forwarder; <code>listforwarders</code> lists all the current RTP forwarders on a specific AudioBridge room instance. As an alternative, you can configure a single static RTP forwarder in the plugin configuration file. A finer grained control of what to forward externally, in terms of participants mix, can be achieved using groups.</p>
<p><code>create</code> can be used to create a new audio room, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "create",
        "room" : &lt;unique numeric ID, optional, chosen by plugin if missing&gt;,
        "permanent" : &lt;true|false, whether the room should be saved in the config file, default=false&gt;,
        "description" : "&lt;pretty name of the room, optional&gt;",
        "secret" : "&lt;password required to edit/destroy the room, optional&gt;",
        "pin" : "&lt;password required to join the room, optional&gt;",
        "is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "allowed" : [ array of string tokens users can use to join this room, optional],
        "sampling_rate" : &lt;sampling rate of the room, optional, 16000 by default&gt;,
        "spatial_audio" : &lt;true|false, whether the mix should spatially place users, default=false&gt;,
        "audiolevel_ext" : &lt;true|false, whether the ssrc-audio-level RTP extension must be negotiated for new joins, default=true&gt;,
        "audiolevel_event" : &lt;true|false (whether to emit event to other users or not)&gt;,
        "audio_active_packets" : &lt;number of packets with audio level (default=100, 2 seconds)&gt;,
        "audio_level_average" : &lt;average value of audio level (127=muted, 0='too loud', default=25)&gt;,
        "default_expectedloss" : &lt;percent of packets we expect participants may miss, to help with outgoing FEC (default=0, max=20; automatically used for forwarders too)&gt;,
        "default_bitrate" : &lt;bitrate in bps to use for the all participants (default=0, which means libopus decides; automatically used for forwarders too)&gt;,
        "denoise" : &lt;true|false, whether denoising via RNNoise should be performed for each participant by default, default=false&gt;,
        "record" : &lt;true|false, whether to record the room or not, default=false&gt;,
        "record_file" : "&lt;/path/to/the/recording.wav, optional&gt;",
        "record_dir" : "&lt;/path/to/, optional; makes record_file a relative path, if provided&gt;",
        "mjrs" : &lt;true|false (whether all participants in the room should be individually recorded to mjr files, default=false)&gt;,
        "mjrs_dir" : "&lt;/path/to/, optional&gt;",
        "allow_rtp_participants" : &lt;true|false, whether participants should be allowed to join via plain RTP as well, default=false&gt;,
        "groups" : [ non-hierarchical array of string group names to use to gat participants, for external forwarding purposes only, optional]
}
</pre><p>A successful creation procedure will result in a <code>created</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "created",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if saved to config file, false if not&gt;
}
</pre><p>If you requested a permanent room but a <code>false</code> value is returned instead, good chances are that there are permission problems.</p>
<p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Notice that, in general, all users can create rooms. If you want to limit this functionality, you can configure an admin <code>admin_key</code> in the plugin settings. When configured, only "create" requests that include the correct <code>admin_key</code> value in an "admin_key" property will succeed, and will be rejected otherwise. Notice that you can optionally extend this functionality to RTP forwarding as well, in order to only allow trusted clients to use that feature.</p>
<p>Once a room has been created, you can still edit some (but not all) of its properties using the <code>edit</code> request. This allows you to modify the room description, secret, pin and whether it's private or not: you won't be able to modify other more static properties, like the room ID, the sampling rate, the extensions-related stuff and so on. If you're interested in changing the ACL, instead, check the <code>allowed</code> message. An <code>edit</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "edit",
        "room" : &lt;unique numeric ID of the room to edit&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "new_description" : "&lt;new pretty name of the room, optional&gt;",
        "new_secret" : "&lt;new password required to edit/destroy the room, optional&gt;",
        "new_pin" : "&lt;new PIN required to join the room, PIN will be removed if set to an empty string, optional&gt;",
        "new_is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "new_record_dir" : "&lt;new path where new recording files should be saved&gt;",
        "new_mjrs_dir" : "&lt;new path where new MJR files should be saved&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful edit procedure will result in an <code>edited</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "edited",
        "room" : &lt;unique numeric ID&gt;
}
</pre><p>On the other hand, <code>destroy</code> can be used to destroy an existing audio room, whether created dynamically or statically, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "destroy",
        "room" : &lt;unique numeric ID of the room to destroy&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful destruction procedure will result in a <code>destroyed</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "destroyed",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true|false, whether the room is also removed from the config file&gt;
}
</pre><p>This will also result in a <code>destroyed</code> event being sent to all the participants in the audio room, which will look like this:</p>
<pre class="fragment">{
        "audiobridge" : "destroyed",
        "room" : &lt;unique numeric ID of the destroyed room&gt;
}
</pre><p>To enable or disable recording of mixed audio stream while the conference is in progress, you can make use of the <code>enable_recording</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "enable_recording",
        "room" : &lt;unique numeric ID of the room&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;"
        "record" : &lt;true|false, whether this room should be automatically recorded or not&gt;,
        "record_file" : "&lt;file where audio recording should be saved (optional)&gt;",
        "record_dir" : "&lt;path where audio recording file should be saved (optional)&gt;"
}
</pre><p>A room can also be recorded by saving the individual contributions of participants to separate MJR files instead, in a format compatible with the <a class="el" href="recordings.html">Recordings</a>. While a recording for each participant can be enabled or disabled separately, there also is a request to enable or disable them in bulk, thus implementing a feature similar to <code>enable_recording</code> but for MJR files, rather than for a <code></code>.wav mix. This can be done using the <code>enable_mjrs</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "enable_mjrs",
        "room" : &lt;unique numeric ID of the room&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;"
        "mjrs" : &lt;true|false, whether all participants in the room should be individually recorded to mjr files or not&gt;,
        "mjrs_dir" : "&lt;path where all MJR files should be saved to (optional)&gt;"
}
</pre><p>You can check whether a room exists using the <code>exists</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "exists",
        "room" : &lt;unique numeric ID of the room to check&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "exists" : &lt;true|false&gt;
}
</pre><p>You can configure whether to check tokens or add/remove people who can join a room using the <code>allowed</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "allowed",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "action" : "enable|disable|add|remove",
        "room" : &lt;unique numeric ID of the room to update&gt;,
        "allowed" : [
                // Array of strings (tokens users might pass in "join", only for add|remove)
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "allowed" : [
                // Updated, complete, list of allowed tokens (only for enable|add|remove)
        ]
}
</pre><p>If you're the administrator of a room (that is, you created it and have access to the secret) you can kick participants using the <code>kick</code> request. Notice that this only kicks the user out of the room, but does not prevent them from re-joining: to ban them, you need to first remove them from the list of authorized users (see <code>allowed</code> request) and then <code>kick</code> them. The <code>kick</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "kick",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to kick&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>If you're the administrator of a room (that is, you created it and have access to the secret) you can kick all participants using the <code>kick_all</code> request. Notice that this only kicks all users out of the room, but does not prevent them from re-joining: to ban them, you need to first remove them from the list of authorized users (see <code>allowed</code> request) and then perform <code>kick_all</code>. The <code>kick_all</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "kick_all",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>Another option available for administrators is suspending participants: in that case, participants are not kicked from the room (they remain in), but their contribution is not added to the mix, and they don't receive any audio from the mix either. This is a useful option to temporarily detach a participant from the room (e.g., because they'll be busy somewhere else) while still allowing them to keep the existing PeerConnection up and running, so that it can be quickly restored when they're back; since they're not part of the mix and don't receive any audio, the CPU resources to manage them are reduced as well. By default these suspended users participants will still receive events related to changes in the room (e.g., participants joining and leaving, mutes and unmutes, etc.), but these can be disabled too in case saving unnecessary signalling is desired: in that case, a suspended participant will only receive a recap of the current status when resumed. The <code>suspend</code> request must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "suspend",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to suspend&gt;,
        "pause_events" : &lt;whether room events should be paused while suspended; optional, false by default&gt;
        "stop_record" : &lt;whether the MIR recording of this participant should be stopped too; optional, false by default&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>Resuming a suspended participant means bringing them back in the audio mix, and allowing them to hear audio through the PeerConnection once more. In case events were paused, they'll be resumed and a recap will be sent. The <code>resume</code> request must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "resume",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the suspended participant to resume&gt;,
        "record": &lt;true|false, whether to record this resumed user's contribution to a .mjr file (mixer not involved); optional, false by default&gt;,
        "filename": "&lt;basename of the file to record to, -audio.mjr will be added by the plugin; optional, will be relative to mjrs_dir, if configured in the room&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>Both <code>suspend</code> and <code>resume</code> on a participant will result in a notification to the other participants in the room, which means they'll all be notified about a participant being suspended or resumed.</p>
<p>To get a list of the available rooms (excluded those configured or created as private rooms) you can make use of the <code>list</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list"
}
</pre><p>A successful request will produce a list of rooms in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "rooms" : [             // Array of room objects
                {       // Room #1
                        "room" : &lt;unique numeric ID&gt;,
                        "description" : "&lt;Name of the room&gt;",
                        "pin_required" : &lt;true|false, whether a PIN is required to join this room&gt;,
                        "sampling_rate" : &lt;sampling rate of the mixer&gt;,
                        "spatial_audio" : &lt;true|false, whether the mix has spatial audio (stereo)&gt;,
                        "record" : &lt;true|false, whether the room is being recorded&gt;,
                        "num_participants" : &lt;count of the participants&gt;
                },
                // Other rooms
        ]
}
</pre><p>To get a list of the available rooms (excluded those configured or created as private rooms) you can make use of the <code>list</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list"
}
</pre><p>A successful request will produce a list of rooms in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "rooms" : [             // Array of room objects
                {       // Room #1
                        "room" : &lt;unique numeric ID&gt;,
                        "description" : "&lt;Name of the room&gt;",
                        "pin_required" : &lt;true|false, whether a PIN is required to join this room&gt;,
                        "sampling_rate" : &lt;sampling rate of the mixer&gt;,
                        "spatial_audio" : &lt;true|false, whether the mix has spatial audio (stereo)&gt;,
                        "record" : &lt;true|false, whether the room is being recorded&gt;,
                        "num_participants" : &lt;count of the participants&gt;
                },
                // Other rooms
        ]
}
</pre><p>To get a list of the participants in a specific room, instead, you can make use of the <code>listparticipants</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listparticipants",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of participants in a <code>participants</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "participants",
        "room" : &lt;unique numeric ID of the room&gt;,
        "participants" : [              // Array of participant objects
                {       // Participant #1
                        "id" : &lt;unique numeric ID of the participant&gt;,
                        "display" : "&lt;display name of the participant, if any; optional&gt;",
                        "setup" : &lt;true|false, whether user successfully negotiate a WebRTC PeerConnection or not&gt;,
                        "muted" : &lt;true|false, whether user is muted or not&gt;,
                        "suspended" : &lt;true|false, whether user is suspended or not&gt;,
                        "talking" : &lt;true|false, whether user is talking or not (only if audio levels are used)&gt;,
                        "spatial_position" : &lt;in case spatial audio is used, the panning of this participant (0=left, 50=center, 100=right)&gt;,
                },
                // Other participants
        ]
}
</pre><p>To mark the Opus decoder context for the current participant as invalid and force it to be recreated, use the <code>resetdecoder</code> request:</p>
<pre class="fragment">{
        "request" : "resetdecoder"
}
</pre><p>A successful request will produce a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success"
}
</pre><p>You can add a new RTP forwarder for an existing room using the <code>rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "rtp_forward",
        "room" : &lt;unique numeric ID of the room to add the forwarder to&gt;,
        "group" : "&lt;group to forward, if enabled in the room (forwards full mix if missing)&gt;",
        "ssrc" : &lt;SSRC to use to use when streaming (optional: stream_id used if missing)&gt;,
        "codec" : "&lt;opus (default), pcma (A-Law) or pcmu (mu-Law)&gt;",
        "ptype" : &lt;payload type to use when streaming (optional: 100 used if missing)&gt;,
        "host" : "&lt;host address to forward the RTP packets to&gt;",
        "host_family" : "&lt;ipv4|ipv6, if we need to resolve the host address to an IP; by default, whatever we get&gt;",
        "port" : &lt;port to forward the RTP packets to&gt;,
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;",
        "always_on" : &lt;true|false, whether silence should be forwarded when the room is empty&gt;
}
</pre><p>The concept of "groups" is particularly important, here, in case groups were enabled when creating a room. By default, in fact, if a room has groups disabled, then an RTP forwarder will simply relay the mix of all active participants; sometimes, though, an external application may want to only receive the mix of some of the participants, and not all of them. This is what groups are for: if you tag participants with a specific group name, then creating a new forwarder that explicitly references that group name will ensure that only a mix of the participants tagged with that name will be forwarded. As such, it's important to point out groups <b>only</b> impact forwarders, and <code>NOT</code> participants or how they're mixed in main mix for the room itself. Omitting a group name when creating a forwarder for a room where groups are enabled will simply fall back to the default behaviour of forwarding the full mix.</p>
<p>Notice that, as explained above, in case you configured an <code>admin_key</code> property and extended it to RTP forwarding as well, you'll need to provide it in the request as well or it will be rejected as unauthorized. By default no limitation is posed on <code>rtp_forward</code> .</p>
<p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "group" : "&lt;group to forward, same as request if provided&gt;",
        "stream_id" : &lt;unique numeric ID assigned to the new RTP forwarder&gt;,
        "host" : "&lt;host this forwarder is streaming to, same as request if not resolved&gt;",
        "port" : &lt;audio port this forwarder is streaming to, same as request&gt;
}
</pre><p>To stop a previously created RTP forwarder and stop it, you can use the <code>stop_rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "stop_rtp_forward",
        "room" : &lt;unique numeric ID of the room to remove the forwarder from&gt;,
        "stream_id" : &lt;unique numeric ID of the RTP forwarder&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "stream_id" : &lt;unique numeric ID, same as request&gt;
}
</pre><p>To get a list of the forwarders in a specific room, instead, you can make use of the <code>listforwarders</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listforwarders",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of RTP forwarders in a <code>forwarders</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "forwarders",
        "room" : &lt;unique numeric ID of the room&gt;,
        "rtp_forwarders" : [            // Array of RTP forwarder objects
                {       // RTP forwarder #1
                        "stream_id" : &lt;unique numeric ID of the forwarder&gt;,
                        "group" : "&lt;group that is being forwarded, if available&gt;",
                        "ip" : "&lt;IP this forwarder is streaming to&gt;",
                        "port" : &lt;port this forwarder is streaming to&gt;,
                        "ssrc" : &lt;SSRC this forwarder is using, if any&gt;,
                        "codec" : &lt;codec this forwarder is using, if any&gt;,
                        "ptype" : &lt;payload type this forwarder is using, if any&gt;,
                        "srtp" : &lt;true|false, whether the RTP stream is encrypted&gt;,
                        "always_on" : &lt;true|false, whether this forwarder works even when no participant is in or not&gt;
                },
                // Other forwarders
        ]
}
</pre><p>As anticipated, while the AudioBridge is mainly meant to allow real users to interact with each other by mixing their contributions, you can also start the playback of one or more pre-recorded audio files in a mix: this is especially useful whenever you have, for instance, to play an announcement of some sort, or when maybe you want to play some background music (e.g., some music on hold when the room is empty). You can start the playback of an .opus file in an existing room using the <code>play_file</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "play_file",
        "room" : &lt;unique numeric ID of the room to play the file in&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "group" : "&lt;group to play in (for forwarding purposes only; optional, mandatory if enabled in the room)&gt;",
        "file_id": "&lt;unique string ID of the announcement; random if not provided&gt;",
        "filename": "&lt;path to the Opus file to play&gt;",
        "loop": &lt;true|false, depending on whether or not the file should be played in a loop forever&gt;
}
</pre><p>Notice that, as explained above, in case you configured an <code>admin_key</code> property and extended it to RTP forwarding as well, you'll need to provide it in the request as well or it will be rejected as unauthorized. By default <code>play_file</code> only requires the room secret, meaning only people authorized to edit the room can start an audio playback.</p>
<p>Also notice that the only supported files are .opus files: no other audio format will be accepted. Besides, the file must be reachable and available on the file system: network addresses (e.g., HTTP URL) are NOT supported.</p>
<p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement, same as request if provided or randomly generated otherwise&gt;"
}
</pre><p>As soon as the playback actually starts (usually immediately after the request has been sent), an event is sent to all participants so that they're aware something is being played back in the room besides themselves:</p>
<pre class="fragment">{
        "audiobridge" : "announcement-started",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A similar event is also sent whenever the playback stops, whether it's because the file ended and <code>loop</code> was <code>FALSE</code> (which will automatically clear the resources) or because a <code>stop_file</code> request asked for the playback to be interrupted or <code>stop_all_files</code> request asked for all playbacks to be interrupted:</p>
<pre class="fragment">{
        "audiobridge" : "announcement-stopped",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>You can check whether a specific playback is still going on in a room, you can use the <code>is_playing</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "is_playing",
        "room" : &lt;unique numeric ID of the room where the playback is taking place&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;",
        "playing" : &lt;true|false&gt;
}
</pre><p>To get a list of the announcements in a specific room, you can make use of the <code>listannouncements</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listannouncements",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of announcements in a <code>announcements</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "announcements",
        "room" : &lt;unique numeric ID of the room&gt;,
        "announcements" : [             // Array of announcement objects
                {       // Announcement #1
                        "file_id" : "&lt;unique string ID of the announcement&gt;",
                        "filename": "&lt;path to the Opus file to play&gt;",
                        "playing" : &lt;true|false, whether or not the file is playing&gt;,
                        "loop": &lt;true|false, depending on whether or not the file is playing in a loop forever&gt;
                }
                // Other announcements
        ]
}
</pre><p>As anticipated, when not looping a playback will automatically stop and self-destruct when it reaches the end of the audio file. In case you want to stop a playback sooner than that, or want to stop a looped playback, you can use the <code>stop_file</code> request:</p>
<pre class="fragment">{
        "request" : "stop_file",
        "room" : &lt;unique numeric ID of the room where the playback is taking place&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "file_id": "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the now interrupted announcement&gt;"
}
</pre><p>In case you want to stop all playbacks of a room immediatly, you can use the <code>stop_all_files</code> request:</p>
<pre class="fragment">{
        "request" : "stop_all_files",
        "room" : &lt;unique numeric ID of the room where the playback is taking place&gt;,
        "secret" : "&lt;room password, if configured&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id_list" : [
                // Array of file_id identifiers, as strings
        ]
}
</pre><p>That completes the list of synchronous requests you can send to the AudioBridge plugin. As anticipated, though, there are also several asynchronous requests you can send, specifically those related to joining and updating one's presence as a participant in an audio room.</p>
<p>The way you'd interact with the plugin is usually as follows:</p>
<ol type="1">
<li>you use a <code>join</code> request to join an audio room, and wait for the <code>joined</code> event; this event will also include a list of the other participants, if any;</li>
<li>you send a <code>configure</code> request attached to an audio-only JSEP offer to start configuring your participation in the room (e.g., join unmuted or muted), and wait for the related <code>event</code>, which will be attached to a JSEP answer by the plugin to complete the setup of the WebRTC PeerConnection;</li>
<li>you send other <code>configure</code> requests (without any JSEP-related attachment) to mute/unmute yourself during the audio conference;</li>
<li>you intercept events originated by the plugin (<code>joined</code> , <code>leaving</code> ) to notify you about users joining/leaving/muting/unmuting;</li>
<li>you eventually send a <code>leave</code> request to leave a room; if you leave the PeerConnection instance intact, you can subsequently join a different room without requiring a new negotiation (and so just use a <code>join</code> + JSEP-less <code>configure</code> to join).</li>
</ol>
<p>Notice that there's also a <code>changeroom</code> request available: you can use this request to immediately leave the room you're in and join a different one, without requiring you to do a <code>leave</code> + <code>join</code> + <code>configure</code> round. Of course remember not to pass any JSEP-related payload when doing a <code>changeroom</code> as the same pre-existing PeerConnection will be re-used for the purpose.</p>
<p>Notice that you can also ask the AudioBridge plugin to send you an offer, when you join, rather than providing one yourself: this means that the SDP offer/answer roles would be reversed, and so you'd have to provide an answer yourself in this case. Remember that, in case renegotiations or restarts take place, they MUST follow the same negotiation pattern as the one that originated the connection: it's an error to send an SDP offer to the plugin to update a PeerConnection, if the plugin sent you an offer originally. It's advised to let users generate the offer, and let the plugin answer: this reverserd role is mostly here to facilitate the setup of cascaded mixers, e.g., allow one AudioBridge to connect to the other via WebRTC (which wouldn't be possible if both expected an offer from the other). Refer to the <a class="el" href="audiobridge.html#aboffer">AudioBridge-generated offers</a> section for more details.</p>
<p>About the syntax of all the above mentioned requests, <code>join</code> has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "join",
        "room" : &lt;numeric ID of the room to join&gt;,
        "id" : &lt;unique ID to assign to the participant; optional, assigned by the plugin if missing&gt;,
        "group" : "&lt;group to assign to this participant (for forwarding purposes only; optional, mandatory if enabled in the room)&gt;",
        "pin" : "&lt;password required to join the room, if any; optional&gt;",
        "display" : "&lt;display name to have in the room; optional&gt;",
        "token" : "&lt;invitation token, in case the room has an ACL; optional&gt;",
        "muted" : &lt;true|false, whether to start unmuted or muted&gt;,
        "suspended" : &lt;true|false, whether to start suspended or not (false by default)&gt;,
        "pause_events" : &lt;whether room events should be paused, if the user is joining as suspended; optional, false by default&gt;
        "codec" : "&lt;codec to use, among opus (default), pcma (A-Law) or pcmu (mu-Law)&gt;",
        "bitrate" : &lt;bitrate to use for the Opus stream in bps; optional, default=0 (libopus decides)&gt;,
        "quality" : &lt;0-10, Opus-related complexity to use, the higher the value, the better the quality (but more CPU); optional, default is 4&gt;,
        "expected_loss" : &lt;0-20, a percentage of the expected loss (capped at 20%), only needed in case outgoing FEC is used; optional, default is 0 (FEC disabled even when negotiated) or the room default&gt;,
        "volume" : &lt;percent value, &lt;100 reduces volume, &gt;100 increases volume; optional, default is 100 (no volume change)&gt;,
        "spatial_position" : &lt;in case spatial audio is enabled for the room, panning of this participant (0=left, 50=center, 100=right)&gt;,
        "denoise" : &lt;true|false, whether denoising via RNNoise should be performed for this participant (default=room value)&gt;,
        "secret" : "&lt;room management password; optional, if provided the user is an admin and can't be globally muted with mute_room&gt;",
        "audio_level_average" : "&lt;if provided, overrides the room audio_level_average for this user; optional&gt;",
        "audio_active_packets" : "&lt;if provided, overrides the room audio_active_packets for this user; optional&gt;",
        "record": &lt;true|false, whether to record this user's contribution to a .mjr file (mixer not involved)&gt;,
        "filename": "&lt;basename of the file to record to, -audio.mjr will be added by the plugin; will be relative to mjrs_dir, if configured in the room&gt;"
}
</pre><p>A successful request will produce a <code>joined</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "joined",
        "room" : &lt;numeric ID of the room&gt;,
        "id" : &lt;unique ID assigned to the participant&gt;,
        "display" : "&lt;display name of the new participant&gt;",
        "participants" : [
                // Array of existing participants in the room
        ]
}
</pre><p>The other participants in the room will be notified about the new participant by means of a different <code>joined</code> event, which will only include the <code>room</code> and the new participant as the only object in a <code>participants</code> array.</p>
<p>Notice that, while the AudioBridge assumes participants will exchange media via WebRTC, there's a less known feature that allows you to use plain RTP to join an AudioBridge room instead. This functionality may be helpful in case you want, e.g., SIP based endpoints to join an AudioBridge room, by crafting SDPs for the SIP dialogs yourself using the info exchanged with the plugin. In order to do that, you keep on using the API to join as a participant as explained above, but instead of negotiating a PeerConnection as you usually would, you add an <code>rtp</code> object to the <code>join</code> request, which needs to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "join",
        [..]
        "rtp" : {
                "ip" : "&lt;IP address you want media to be sent to&gt;",
                "port" : &lt;port you want media to be sent to&gt;,
                "payload_type" : &lt;payload type to use for RTP packets (optional; only needed in case Opus is used, automatic for G.711)&gt;,
                "audiolevel_ext" : &lt;ID of the audiolevel RTP extension, if used (optional)&gt;,
                "fec" : &lt;true|false, whether FEC from Janus to the user should be enabled for the Opus stream (optional; only needed in case Opus is used)&gt;
        }
}
</pre><p>In that case, the participant will be configured to use plain RTP to exchange media with the room, and the <code>joined</code> event will include an <code>rtp</code> object as well to complete the negotiation:</p>
<pre class="fragment">{
        "audiobridge" : "joined",
        [..]
        "rtp" : {
                "ip" : "&lt;IP address the AudioBridge will expect media to be sent to&gt;",
                "port" : &lt;port the AudioBridge will expect media to be sent to&gt;,
                "payload_type" : &lt;payload type to use for RTP packets (optional; only needed in case Opus is used, automatic for G.711)&gt;
        }
}
</pre><p>Notice that if no ip/port are provided, it means this participant will only send media, and will not receive any (e.g., for injecting audio). This means the AudioBridge plugin will only start sending media via RTP if it received a valid ip/port from the remote paricipant endpoint. If you're interested in supporting scenarios where the AudioBridge "dials out" (e.g., for outgoing INVITES to SIP endpoints) check the <a class="el" href="audiobridge.html#aboffer">AudioBridge-generated offers</a> section.</p>
<p>At this point, whether the participant will be interacting via WebRTC or plain RTP, the media-related settings of the participant can be modified by means of a <code>configure</code> request. The <code>configure</code> request has to be formatted as follows (notice that all parameters except <code>request</code> are optional, depending on what you want to change):</p>
<pre class="fragment">{
        "request" : "configure",
        "muted" : &lt;true|false, whether to unmute or mute&gt;,
        "display" : "&lt;new display name to have in the room&gt;",
        "bitrate" : &lt;new bitrate to use for the Opus stream (see "join" for more info)&gt;,
        "quality" : &lt;new Opus-related complexity to use (see "join" for more info)&gt;,
        "expected_loss" : &lt;new value for the expected loss (see "join" for more info)&gt;
        "volume" : &lt;new volume percent value (see "join" for more info)&gt;,
        "spatial_position" : &lt;in case spatial audio is enabled for the room, new panning of this participant (0=left, 50=center, 100=right)&gt;,
        "denoise" : &lt;true|false, whether denoising via RNNoise should be performed for this participant (default=room value)&gt;,
        "record": &lt;true|false, whether to record this user's contribution to a .mjr file (mixer not involved),
        "filename": "&lt;basename of the file to record to, -audio.mjr will be added by the plugin; will be relative to mjrs_dir, if configured in the room&gt;",
        "group" : "&lt;new group to assign to this participant, if enabled in the room (for forwarding purposes)&gt;"
}
</pre><p><code>muted</code> instructs the plugin to mute or unmute the participant; <code>quality</code> changes the complexity of the Opus encoder for the participant; <code>record</code> can be used to record this participant's contribution to a Janus .mjr file, and <code>filename</code> to provide a basename for the path to save the file to (notice that this is different from the recording of a whole room: this feature only records the packets this user is sending, and is not related to the mixer stuff). A successful request will result in a <code>ok</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "room" : &lt;numeric ID of the room&gt;,
        "result" : "ok"
}
</pre><p>In case the <code>muted</code> property was modified, the other participants in the room will be notified about this by means of a <code>event</code> notification, which will only include the <code>room</code> and the updated participant as the only object in a <code>participants</code> array.</p>
<p>If you're the administrator of a room (that is, you created it and have access to the secret) you can mute or unmute individual participants using the <code>mute</code> or <code>unmute</code> request</p>
<pre class="fragment">{
        "request" : "&lt;mute|unmute, whether to mute or unmute&gt;",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to mute|unmute&gt;
}
</pre><p>A successful request will result in a success response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>To mute/unmute the whole room, use <code>mute_room</code> and <code>unmute_room</code> instead.</p>
<pre class="fragment">{
        "request" : "&lt;mute_room|unmute_room, whether to mute or unmute&gt;",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will result in a success response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>As anticipated, you can leave an audio room using the <code>leave</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "leave"
}
</pre><p>The leaving user will receive a <code>left</code> notification:</p>
<pre class="fragment">{
        "audiobridge" : "left",
        "room" : &lt;numeric ID of the room&gt;,
        "id" : &lt;numeric ID of the participant who left&gt;
}
</pre><p>All the other participants will receive an <code>event</code> notification with the ID of the participant who just left:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "room" : &lt;numeric ID of the room&gt;,
        "leaving" : &lt;numeric ID of the participant who left&gt;
}
</pre><p>For what concerns the <code>changeroom</code> request, instead, it's pretty much the same as a <code>join</code> request and as such has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "changeroom",
        "room" : &lt;numeric ID of the room to move to&gt;,
        "id" : &lt;unique ID to assign to the participant; optional, assigned by the plugin if missing&gt;,
        "pin" : "&lt;password required to join the room, optional&gt;",
        "group" : "&lt;group to assign to this participant (for forwarding purposes only; optional, mandatory if enabled in the new room)&gt;",
        "display" : "&lt;display name to have in the room; optional&gt;",
        "token" : "&lt;invitation token, in case the new room has an ACL; optional&gt;",
        "muted" : &lt;true|false, whether to start unmuted or muted&gt;,
        "suspended" : &lt;true|false, whether to start suspended or not&gt;,
        "pause_events" : &lt;whether room events should be paused, if the user is joining as suspended; optional, false by default&gt;
        "bitrate" : &lt;bitrate to use for the Opus stream in bps; optional, default=0 (libopus decides)&gt;,
        "quality" : &lt;0-10, Opus-related complexity to use, higher is higher quality; optional, default is 4&gt;,
        "expected_loss" : &lt;0-20, a percentage of the expected loss (capped at 20%), only needed in case outgoing FEC is used; optional, default is 0 (FEC disabled even when negotiated) or the room default&gt;,
        "volume" : &lt;new volume percent value (see "join" for more info)&gt;,
        "spatial_position" : &lt;in case spatial audio is enabled for the room, new panning of this participant (0=left, 50=center, 100=right)&gt;,
        "denoise" : &lt;true|false, whether denoising via RNNoise should be performed for this participant (default=room value, or whether it was active before)&gt;
}
</pre><p>Such a request will trigger all the above-described leaving/joined events to the other participants, as it is indeed wrapping a <code>leave</code> followed by a <code>join</code> and as such the other participants in both rooms need to be updated accordingly. The participant who switched room instead will be sent a <code>roomchanged</code> event which is pretty similar to what <code>joined</code> looks like:</p>
<p>A successful request will produce a <code>joined</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "roomchanged",
        "room" : &lt;numeric ID of the new room&gt;,
        "id" : &lt;unique ID assigned to the participant in the new room&gt;,
        "display" : "&lt;display name of the new participant&gt;",
        "participants" : [
                // Array of existing participants in the new room
        ]
}
</pre><p>As a last note, notice that the AudioBridge plugin does support renegotiations, mostly for the purpose of facilitating ICE restarts: in fact, there isn't much need for renegotiations outside of that context, as PeerConnections here will typically always contain a single m-line for audio, and so adding/removing streams makes no sense; besides, muting and unmuting is available via APIs, meaning that updating the media direction via SDP renegotiations would be overkill.</p>
<p>To force a renegotiation, all you need to do is send the new JSEP offer together with a <code>configure</code> request: this request doesn't need to contain any directive at all, and can be empty. A JSEP answer will be sent back along the result of the request, if successful.</p>
<h2><a class="anchor" id="aboffer"></a>
AudioBridge-generated offers</h2>
<p>As anticipated in the previous sections, by default the AudioBridge plugin expects an SDP offer from users interested to join a room, and generates an SDP answer to complete the WebRTC negotiation process: this SDP offer can be provided either in a <code>join</code> request or a <code>configure</code> one, depending on how the app is constructed.</p>
<p>It's worth pointing out that the AudioBridge plugin also supports reversed roles when it comes to negotiation: that is, a user can ask the plugin to generate an SDP offer first, to which they'd provide an SDP answer to. This slightly changes the way the negotiation works within the context of the AudioBridge API, as some messages may have to be used in a different way. More specifically, if a user wants the plugin to generate an offer, they'll have to include a:</p>
<pre class="fragment">        [..]
        "generate_offer" : true,
        [..]
}
</pre><p>property in the <code>join</code> or <code>configure</code> request used to setup the PeerConnection. This means that the user will receive a JSEP SDP offer as part of the related event: at this point, the user needs to prepare to send a JSEP SDP answer and send it back to the plugin to complete the negotiation. The user must use the <code>configure</code> request to provide this SDP answer: no need to provide additional attributes in the request, unless it's needed for application related purposes (e.g., to start muted).</p>
<p>Notice that this does have an impact on renegotiations, e.g., for ICE restarts or changes in the media direction. As a policy, plugins in Janus tend to enforce the same negotiation pattern used to setup the PeerConnection initially for renegotiations too, as it reduces the risk of issues like glare: this means that users will NOT be able to send an SDP offer to the AudioBridge plugin to update an existing PeerConnection, if that PeerConnection had previously been originated by a plugin offer instead. The plugin will treat this as an error.</p>
<p>The <code>generate_offer</code> feature also works for plain RTP participants. If you want to use them in that context (e.g., because you want to first obtain the AudioBridge's RTP details to craft a SIP INVITE, and only later provide the remote RTP details back to the plugin), set the <code>generate_offer</code> property to <code>true</code> and pass an <code>rtp</code> object without <code>ip</code> and <code>port</code> (an empty <code>rtp</code> object will work too). This will instruct the plugin to return its own connectivity information first. When you are aware of the connectivity information for the participant side (e.g., because you got a SIP 200 OK back), pass a new <code>rtp</code> object with <code>ip</code> and <code>port</code> in a <code>configure</code> request on the participant handle, which will finalize the media establishment. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Thu Apr 24 2025 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2025
</div>
</body>
</html>
