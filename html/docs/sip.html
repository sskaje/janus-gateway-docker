<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SIP plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.9.2/umd/popper.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.2/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.2/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 2001;" src="forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<div class="navbar navbar-expand-lg fixed-top navbar-dark bg-primary">
<div class="container">
	<a class="navbar-brand" href="/">Janus (multistream)</a>
	<button type="button" class="navbar-toggler" data-toggle="collapse" data-target=".navbar-collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false">
		<span class="navbar-toggler-icon"></span>
	</button>
	<div class="navbar-collapse collapse" id="navbarResponsive">
		<ul class="navbar-nav">
			<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
			<li class="nav-item"><a class="nav-link" href="/demos/">Demos</a></li>
			<li class="nav-item"><a class="nav-link active" href="index.html">Documentation</a></li>
			<li class="nav-item"><a class="nav-link" href="/citeus.html">Papers</a></li>
			<li class="nav-item"><a class="nav-link" href="/support.html">Need help?</a></li>
			<li class="nav-item"><a class="nav-link" href="https://janus-legacy.conf.meetecho.com/">Janus (0.x)</a></li>
			<li class="nav-item"><a class="nav-link januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<ul class="navbar-nav ms-auto">
			<li class="nav-item">
				<a class="nav-link meetecho-logo" target="_blank" href="https://www.meetecho.com">
					<img src="meetecho-logo.png"/>
				</a>
			</li>
		</ul>
	</div>
</div>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">SIP plugin documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a simple SIP plugin for Janus, allowing WebRTC peers to register at a SIP server (e.g., Asterisk) and call SIP user agents through a Janus instance. Specifically, when attaching to the plugin peers are requested to provide their SIP server credentials, i.e., the address of the SIP server and their username/secret. This results in the plugin registering at the SIP server and acting as a SIP client on behalf of the web peer. Most of the SIP states and lifetime are masked by the plugin, and only the relevant events (e.g., INVITEs and BYEs) and functionality (call, hangup) are made available to the web peer: peers can call extensions at the SIP server or wait for incoming INVITEs, and during a call they can send DTMF tones. Calls can do plain RTP or SDES-SRTP.</p>
<p>The concept behind this plugin is to allow different web pages associated to the same peer, and hence the same SIP user, to attach to the plugin at the same time and yet just do a SIP REGISTER once. The same should apply for calls: while an incoming call would be notified to all the web UIs associated to the peer, only one would be able to pick up and answer, in pretty much the same way as SIP forking works but without the need to fork in the same place. This specific functionality, though, has not been implemented as of yet.</p>
<h1><a class="anchor" id="sipapi"></a>
SIP Plugin API</h1>
<p>All requests you can send in the SIP Plugin API are asynchronous, which means all responses (successes and errors) will be delivered as events with the same transaction.</p>
<p>The supported requests are <code>register</code> , <code>unregister</code> , <code>call</code> , \progress , <code>accept</code> , <code>decline</code> , <code>info</code> , <code>message</code> , <code>dtmf_info</code> , <code>subscribe</code> , <code>unsubscribe</code> , <code>transfer</code> , <code>recording</code> , <code>keyframe</code> , <code>hold</code> , <code>unhold</code> , <code>update</code> and <code>hangup</code> . <code>register</code> can be used, as the name suggests, to register a username at a SIP registrar to call and be called, while <code>unregister</code> unregisters it; <code>call</code> is used to send an INVITE to a different SIP URI through the plugin; in case one is invited instead of inviting, <code>progress</code>, <code>accept</code> and <code>decline</code> requests may be used. <code>progress</code> request is optional, and it is used to send 183 Session Progress response back to the caller, while <code>accept</code> and <code>decline</code> are used to accept or reject the call respectively; <code>transfer</code> takes care of attended and blind transfers (see <a class="el" href="sip.html#siptr">Attended and blind transfers</a> for more details); <code>hold</code> and <code>unhold</code> can be used respectively to put a call on-hold and to resume it; <code>info</code> allows you to send a generic SIP INFO request, while <code>dtmf_info</code> is focused on using INFO for DTMF instead; <code>message</code> is the method you use to send a SIP message to the other peer; <code>subscribe</code> and <code>unsubscribe</code> are used to deal with SIP events, i.e., to send SUBSCRIBE requests that will result in NOTIFY asynchronous events; <code>recording</code> is used, instead, to record the conversation to one or more .mjr files (depending on the direction you want to record); <code>update</code> allows you to update an existing session (e.g., to do a renegotiation or force an ICE restart); finally, <code>hangup</code> can be used to terminate the communication at any time, either to hangup (BYE) an ongoing call or to cancel/decline (CANCEL/BYE) a call that hasn't started yet.</p>
<p>No matter the request, an error response or event is always formatted like this:</p>
<pre class="fragment">{
        "sip" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Notice that the error syntax above refers to the plugin API messaging, and not SIP error codes obtained in response to SIP requests, which are notified using a different syntax:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "&lt;name of the error event&gt;",
                "code" : &lt;SIP error code&gt;,
                "reason" : "&lt;SIP error reason&gt;",
                "reason_header" : "&lt;Reason header text; optional&gt;",
                "reason_header_protocol" : "&lt;Reason header protocol; optional&gt;",
                "reason_header_cause" : "&lt;Reason header cause code; optional&gt;"
        }
}
</pre><p>Coming to the available requests, you send a SIP REGISTER using the <code>register</code> request. To be more precise, a <code>register</code> request MAY result in a SIP REGISTER, as this method actually provides ways to start using a SIP account with no need for a registration. It is the case, for instance, of the so-called <code>guest</code> registrations: if you register as a <code>guest</code> , it means you'll use the provided SIP URI in your <code>From</code> headers for calls, but you will actually not send a SIP REGISTER; this is especially useful for outgoing calls to services that don't require registration (e.g., IVR systems, or conference bridges), but also means you won't be able to receive calls unless peers know what your private SIP address is. A SIP REGISTER isn't sent also when registering as a <code>helper</code> : as we'll explain later, <code>helper</code> sessions are sessions only meant to facilitate the setup of <a class="el" href="sip.html#sipmc">Simultaneous SIP calls using the same account</a>.</p>
<p>That said, a <code>register</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "register",
        "type" : "&lt;if guest or helper, no SIP REGISTER is actually sent; optional&gt;",
        "send_register" : &lt;true|false; if false, no SIP REGISTER is actually sent; optional&gt;,
        "force_udp" : &lt;true|false; if true, forces UDP for the SIP messaging; optional&gt;,
        "force_tcp" : &lt;true|false; if true, forces TCP for the SIP messaging; optional&gt;,
        "sips" : &lt;true|false; if true, configures a SIPS URI too when registering; optional&gt;,
        "rfc2543_cancel" : &lt;true|false; if true, configures sip client to CANCEL pending INVITEs without having received a provisional response first; optional&gt;,
        "username" : "&lt;SIP URI to register; mandatory&gt;",
        "secret" : "&lt;password to use to register; optional&gt;",
        "ha1_secret" : "&lt;prehashed password to use to register; optional&gt;",
        "authuser" : "&lt;username to use to authenticate (overrides the one in the SIP URI); optional&gt;",
        "display_name" : "&lt;display name to use when sending SIP REGISTER; optional&gt;",
        "user_agent" : "&lt;user agent to use when sending SIP REGISTER; optional&gt;",
        "proxy" : "&lt;server to register at; optional, as won't be needed in case the REGISTER is not goint to be sent (e.g., guests)&gt;",
        "outbound_proxy" : "&lt;outbound proxy to use, if any; optional&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP REGISTER; optional&gt;",
        "contact_params" : "&lt;array of key/value objects, to specify custom Contact URI params to add to the SIP REGISTER; optional&gt;",
        "incoming_header_prefixes" : "&lt;array of strings, to specify custom (non-standard) headers to read on incoming SIP events; optional&gt;",
        "refresh" : "&lt;true|false; if true, only uses the SIP REGISTER as an update and not a new registration; optional&gt;",
        "master_id" : "&lt;ID of an already registered account, if this is an helper for multiple calls (more on that later); optional&gt;",
        "register_ttl" : "&lt;integer; number of seconds after which the registration should expire; optional&gt;"
}
</pre><p>A <code>registering</code> event will be sent back, as this is an asynchronous request.</p>
<p>In case it is required to, this request will originate a SIP REGISTER to the specified server with the right credentials. 401 and 407 responses will be handled automatically, and so errors will not be notified back to the caller unless they're definitive (e.g., wrong credentials). A failure to register will return an error with name <code>registration_failed</code>. A successful registration, instead, is notified in a <code>registered</code> event formatted like this:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "registered",
                "username" : &lt;SIP URI username&gt;,
                "register_sent" : &lt;true|false, depending on whether a REGISTER was sent or not&gt;,
                "master_id" : &lt;unique ID of this registered session in the plugin, if a potential master&gt;
        }
}
</pre><p>To unregister, just send an <code>unregister</code> request with no other arguments:</p>
<pre class="fragment">{
        "request" : "unregister"
}
</pre><p>As before, an <code>unregistering</code> event will be sent back. Just as before, this will also send a SIP REGISTER in case it had been sent originally. A successful unregistration is notified in an <code>unregistered</code> event:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "unregistered",
                "username" : &lt;SIP URI username&gt;,
                "register_sent" : &lt;true|false, depending on whether a REGISTER was sent or not&gt;
        }
}
</pre><p>Once registered, you can call or wait to be called: notice that you won't be able to get incoming calls if you chose never to send a REGISTER at all, though.</p>
<p>To send a SIP INVITE, you can use the <code>call</code> request, which has to be formatted like this:</p>
<pre class="fragment">{
        "request" : "call",
        "call_id" : "&lt;user-defined value of Call-ID SIP header used in all SIP requests throughout the call; optional&gt;",
        "uri" : "&lt;SIP URI to call; mandatory&gt;",
        "refer_id" : &lt;in case this is the result of a REFER, the unique identifier that addresses it; optional&gt;,
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP INVITE; optional&gt;",
        "srtp" : "&lt;whether to mandate (sdes_mandatory) or offer (sdes_optional) SRTP support; optional&gt;",
        "srtp_profile" : "&lt;SRTP profile to negotiate, in case SRTP is offered; optional&gt;",
        "secret" : "&lt;password to use to call, only needed in case authentication is needed and no REGISTER was sent; optional&gt;",
        "ha1_secret" : "&lt;prehashed password to use to call, only needed in case authentication is needed and no REGISTER was sent; optional&gt;",
        "authuser" : "&lt;username to use to authenticate as to call, only needed in case authentication is needed and no REGISTER was sent; optional&gt;",
        "autoaccept_reinvites" : &lt;true|false, whether we should blindly accept re-INVITEs with a 200 OK instead of relaying the SDP to the application; optional, TRUE by default&gt;
}
</pre><p>A <code>calling</code> event will be sent back, as this is an asynchronous request.</p>
<p>Notice that this request MUST be associated to a JSEP offer: there's no way to send an offerless INVITE via the SIP plugin. This will generate a SIP INVITE and send it according to the instructions. While a <code>100 Trying</code> will not be notified back to the user, a <code>180 Ringing</code> will, in a <code>ringing</code> event:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related call&gt;",
        "result" : {
                "event" : "ringing",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>If the call is declined, or any other error occurs, a <code>hangup</code> error event will be sent back. If the call is accepted, instead, an <code>accepted</code> event will be sent back to the user, along with the JSEP answer originated by the callee:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related call&gt;",
        "result" : {
                "event" : "accepted",
                "username" : "&lt;SIP URI of the callee&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>At this point, PeerConnection-related considerations aside, the call can be considered established. A SIP ACK is sent automatically by the SIP plugin, so there's no action required of the application to do that manually.</p>
<p>Notice that the SIP plugin supports early-media via <code>183</code> responses responses. In case a <code>183</code> response is received, it's sent back to the user, along with the JSEP answer originated by the callee, in a <code>progress</code> event:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related call&gt;",
        "result" : {
                "event" : "progress",
                "username" : "&lt;SIP URI of the callee&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>In case the caller received a <code>progress</code> event, the following <code>accepted</code> event will NOT contain a JSEP answer, as the one received in the "Session Progress" event will act as the SDP answer for the session.</p>
<p>Notice that you only use <code>call</code> to start a conversation, that is for the first INVITE. To update a session via a re-INVITE, e.g., to renegotiate a session to add/remove streams or force an ICE restart, you do NOT use <code>call</code>, but another request called <code>update</code> instead. This request needs no arguments, as the whole context is derived from the current state of the session. It does need the new JSEP offer to provide, though, as part of the renegotiation.</p>
<pre class="fragment">{
        "request" : "update"
}
</pre><p>An <code>updating</code> event will be sent back, as this is an asynchronous request.</p>
<p>While the <code>call</code> request allows you to send a SIP INVITE (and the <code>update</code> request allows you to update an existing session), there is a way to react to SIP INVITEs as well, that is to handle incoming calls. Incoming calls are notified to the application via <code>incomingcall</code> events:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related call&gt;",
        "result" : {
                "event" : "incomingcall",
                "username" : "&lt;SIP URI of the caller&gt;",
                "displayname" : "&lt;display name of the caller, if available; optional&gt;",
                "callee" : "&lt;SIP URI that was called (in case the user is associated with multiple public URIs)&gt;",
                "referred_by" : "&lt;SIP URI header conveying the identity of the transferor, if this is a transfer; optional&gt;",
                "replaces" : "&lt;call-ID of the call that this is supposed to replace, if this is an attended transfer; optional&gt;",
                "srtp" : "&lt;whether the caller mandates (sdes_mandatory) or offers (sdes_optional) SRTP support; optional&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>The <code>incomingcall</code> may or may not be accompanied by a JSEP offer, depending on whether the caller sent an offerless INVITE or a regular one. Optionally, you can progress the incoming call with the <code>progress</code> request:</p>
<pre class="fragment">{
        "request" : "progress",
        "srtp" : "&lt;whether to mandate (sdes_mandatory) or offer (sdes_optional) SRTP support; optional&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP OK; optional&gt;"
        "autoaccept_reinvites" : &lt;true|false, whether we should blindly accept re-INVITEs with a 200 OK instead of relaying the SDP to the browser; optional, TRUE by default&gt;
}
</pre><p>A <code>progressing</code> event will be sent back, as this is an asynchronous request.</p>
<p>This will result in a <code>183 Session Progress</code> to be sent back to the caller. A <code>progress</code> request must always be accompanied by a JSEP answer (if the <code>incomingcall</code> event contained an offer) or offer (in case it was an offerless INVITE). This request can be used to inform the caller that the early media is available, such as ringback audio, announcements or other audio streams, without the call being fully established.</p>
<p>Furthermore, you can accept the incoming call with the <code>accept</code> request:</p>
<pre class="fragment">{
        "request" : "accept",
        "srtp" : "&lt;whether to mandate (sdes_mandatory) or offer (sdes_optional) SRTP support; optional&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP OK; optional&gt;"
        "autoaccept_reinvites" : &lt;true|false, whether we should blindly accept re-INVITEs with a 200 OK instead of relaying the SDP to the browser; optional, TRUE by default&gt;
}
</pre><p>An <code>accepting</code> event will be sent back, as this is an asynchronous request.</p>
<p>This will result in a <code>200 OK</code> to be sent back to the caller. As was the case for <code>progress</code> request, an <code>accept</code> request must always be accompanied by a JSEP answer (if the <code>incomingcall</code> event contained an offer) or offer (in case it was an offerless INVITE). In the former case, an <code>accepted</code> event will be sent back just to confirm the call can be considered established; in the latter case, instead, an <code>accepting</code> event will be sent back instead, and an <code>accepted</code> event will only follow later, as soon as a JSEP answer is available in the SIP ACK the caller sent back.</p>
<p>Notice that in case you get an incoming call while you're in another call, you will NOT get an <code>incomingcall</code> event, but a <code>missed_call</code> event instead, and just as a notification as there's no way to have two calls at the same time on the same handle in the SIP plugin:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related call&gt;",
        "result" : {
                "event" : "missed_call",
                "caller" : "&lt;SIP URI of the caller&gt;",
                "displayname" : "&lt;display name of the caller, if available; optional&gt;",
                "callee" : "&lt;SIP URI that was called (in case the user is associated with multiple public URIs)&gt;"
        }
}
</pre><p>Besides, you only use <code>accept</code> to answer the first INVITE. To accept a re-INVITE instead, which would be notified via an <code>updatingcall</code> event, you do NOT use <code>accept</code>, but the previously introduced <code>update</code> instead. This request needs no arguments, as the whole context is derived from the current state of the session. It does need the new JSEP answer to provide, though, as part of the renegotiation. As before, an <code>updated</code> event will be sent back, as this is an asynchronous request.</p>
<p>Closing a session depends on the call state. If you have an incoming call that you don't want to accept, use the <code>decline</code> request; in all other cases, use the <code>hangup</code> request instead. Both requests need no additional arguments, as the whole context can be extracted from the current state of the session in the plugin:</p>
<pre class="fragment">{
        "request" : "decline",
        "code" : &lt;SIP code to be sent, if not set, 486 is used; optional&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP request; optional&gt;"
}
</pre><pre class="fragment">{
        "request" : "hangup",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP BYE; optional&gt;"
}
</pre><p>Since these are asynchronous requests, you'll get an event in response: <code>declining</code> if you used <code>decline</code> and <code>hangingup</code> if you used <code>hangup</code>.</p>
<p>As anticipated before, when a call is declined or being hung up, a <code>hangup</code> event is sent instead, which is basically a SIP error event notification as it includes the <code>code</code> and <code>reason</code> . A regular BYE, for instance, would be notified with <code>200</code> and <code>SIP BYE</code>, although a more verbose description may be provided as well.</p>
<p>When a session has been established, there are different requests that you can use to interact with the session.</p>
<p>First of all, you can put a call on-hold with the <code>hold</code> request. By default, this request will send a new INVITE to the peer with a <code>sendonly</code> direction for media, but in case you want to set a different direction (<code>recvonly</code> or <code>inactive</code> ) you can do that by passing a <code>direction</code> attribute as well:</p>
<pre class="fragment">{
        "request" : "hold",
        "direction" : "&lt;sendonly, recvonly or inactive&gt;"
}
</pre><p>No WebRTC renegotiation will be involved here on the holder side, as this will only trigger a re-INVITE on the SIP side. To remove the call from on-hold, just send a <code>unhold</code> request to the plugin, which requires no additional attributes:</p>
<pre class="fragment">{
        "request" : "unhold"
}
</pre><p>and will restore the media direction that was set in the SDP before putting the call on-hold.</p>
<p>The <code>message</code> request allows you to send a SIP MESSAGE to the peer. By default, it is sent in dialog, during active call. But, if the user is registered, it might be sent out of dialog also. In that case the uri parameter is required.</p>
<pre class="fragment">{
        "request" : "message",
        "call_id" : "&lt;user-defined value of Call-ID SIP header used to send the message; optional&gt;",
        "content_type" : "&lt;content type; optional&gt;"
        "content" : "&lt;text to send&gt;",
        "uri" : "&lt;SIP URI of the peer; optional; if set, the message will be sent out of dialog&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP MESSAGE; optional&gt;"
}
</pre><p>A <code>messagesent</code> event will be sent back. Incoming SIP MESSAGEs, instead, are notified in <code>message</code> events:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "message",
                "sender" : "&lt;SIP URI of the message sender&gt;",
                "displayname" : "&lt;display name of the sender, if available; optional&gt;",
                "content_type" : "&lt;content type of the message&gt;",
                "content" : "&lt;content of the message&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>After delivery a <code>messagedelivery</code> event will be sent back with the SIP server response. Used to track the delivery status of the message.</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related message&gt;",
        "result" : {
                "event" : "messagedelivery",
                "code" : "&lt;SIP error code&gt;",
                "reason" : "&lt;SIP error reason&gt;",
        }
}
</pre><p>SIP INFO works pretty much the same way, except that you use an <code>info</code> request to one to the peer:</p>
<pre class="fragment">{
        "request" : "info",
        "type" : "&lt;content type&gt;"
        "content" : "&lt;message to send&gt;",
        "headers" : "&lt;object with key/value mappings (header name/value), to specify custom headers to add to the SIP INFO; optional&gt;"
}
</pre><p>A <code>infosent</code> event will be sent back. Incoming SIP INFOs, instead, are notified in <code>info</code> events:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "info",
                "sender" : "&lt;SIP URI of the message sender&gt;",
                "displayname" : "&lt;display name of the sender, if available; optional&gt;",
                "type" : "&lt;content type of the message&gt;",
                "content" : "&lt;content of the message&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>As anticipated, SIP events are supported as well, using the SUBSCRIBE and NOTIFY mechanism. To do that, you need to use the <code>subscribe</code> request, which has to be formatted like this:</p>
<pre class="fragment">{
        "request" : "subscribe",
        "call_id" : "&lt;user-defined value of Call-ID SIP header used in all SIP requests throughout the subscription; optional&gt;",
        "event" : "&lt;the event to subscribe to, e.g., 'message-summary'; mandatory&gt;",
        "accept" : "&lt;what should be put in the Accept header; optional&gt;",
        "to" : "&lt;who should be the SUBSCRIBE addressed to; optional, will use the user's identity if missing&gt;",
        "subscribe_ttl" : "&lt;integer; number of seconds after which the subscription should expire; optional&gt;",
        "headers" : "&lt;array of key/value objects, to specify custom headers to add to the SIP SUBSCRIBE; optional&gt;"
}
</pre><p>A <code>subscribing</code> event will be sent back, followed by a <code>subscribe_succeeded</code> if the SUBSCRIBE request was accepted, and a <code>subscribe_failed</code> if the transaction failed instead. Incoming SIP NOTIFY events, instead, are notified in <code>notify</code> events:</p>
<pre class="fragment">{
        "sip" : "event",
        "call_id" : "&lt;value of SIP Call-ID header for related subscription&gt;",
        "result" : {
                "event" : "notify",
                "notify" : "&lt;name of the event that the user is subscribed to, e.g., 'message-summary'&gt;",
                "substate" : "&lt;substate of the subscription, e.g., 'active'&gt;",
                "content-type" : "&lt;content-type of the message&gt;"
                "content" : "&lt;content of the message&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>You can also record a SIP call, and it works pretty much the same the VideoCall plugin does. Specifically, you make use of the <code>recording</code> request to either start or stop a recording, using the following syntax:</p>
<pre class="fragment">{
        "request" : "recording",
        "action" : "&lt;start|stop, depending on whether you want to start or stop recording something&gt;"
        "audio" : &lt;true|false; whether or not our audio should be recorded&gt;,
        "video" : &lt;true|false; whether or not our video should be recorded&gt;,
        "peer_audio" : &lt;true|false; whether or not our peer's audio should be recorded&gt;,
        "peer_video" : &lt;true|false; whether or not our peer's video should be recorded&gt;,
        "send_peer_pli" : &lt;true|false; whether or not send PLI to request keyframe from peer&gt;,
        "filename" : "&lt;base path/filename to use for all the recordings&gt;"
}
</pre><p>As you can see, this means that the two sides of conversation are recorded separately, and so are the audio and video streams if available. You can choose which ones to record, in case you're interested in just a subset. The <code>filename</code> part is just a prefix, and dictates the actual filenames that will be used for the up-to-four recordings that may need to be enabled.</p>
<p>A <code>recordingupdated</code> event is sent back in case the request is successful.</p>
<p>To programmatically send a video keyframe request to either the WebRTC user or the SIP peer (or both), the <code>keyframe</code> request can be used. This request is particularly useful when the SIP peer doesn't support RTCP PLI, and so may use other mechanisms (e.g., via signalling) to ask for a keyframe to get video working. By using this request, the WebRTC user can ask Janus to originate a PLI programmatically. The direction of the keyframe request can be provided by using the <code>user</code> and <code>peer</code> properties: if <code>user</code> is <code>TRUE</code> a keyframe request will be sent by Janus to the WebRTC user; if <code>peer</code> is <code>TRUE</code> a keyframe request will be sent by Janus to the SIP peer. In both cases an RTCP PLI message will be sent. The syntax of the message is the following:</p>
<pre class="fragment">{
        "request" : "keyframe",
        "user" : &lt;true|false; whether or not to send a keyframe request to the WebRTC user&gt;,
        "peer" : &lt;true|false; whether or not to send a keyframe request to the SIP peer&gt;
}
</pre><p>A <code>keyframesent</code> event is sent back in case the request is successful.</p>
<h1><a class="anchor" id="sipmc"></a>
Simultaneous SIP calls using the same account</h1>
<p>As anticipated in the previous sections, attaching to the SIP plugin with a Janus handle means creating a SIP stack on behalf of a user or application: this typically means registering an account, and being able to start or receive calls, handle subscriptions, and so on. This also means that, since in Janus each core handle can only be associated with a single PeerConnection, each SIP account is limited to a single call per time: if a user is in a SIP session already, and another call comes in, it's automatically rejected with a <code>486</code> <code>Busy</code> .</p>
<p>While usually not a big deal, there are use cases where it might make sense to be able to support multiple concurrent calls, and maybe switch from one to the other seamlessly. This is possible in the SIP plugin using the so-called <code>helper</code> sessions. Specifically, <code>helper</code> sessions work under the assumption that there's a <code>master</code> session that is registered normally (the "regular" SIP plugin handle, that is), and that these <code>helper</code> sessions can simply be associated to that: any time another concurrent call is needed, if the <code>master</code> session is busy one of the <code>helpers</code> can be used; the more <code>helper</code> sessions are available, the more simultaneous calls can be established.</p>
<p>The way this works is simple:</p>
<ol type="1">
<li>you create a SIP session the usual way, and send a regular <code>register</code> there; this will be the <code>master</code> session, and will return a <code>master_id</code> when successfully registered;</li>
<li>for each <code>helper</code> you want to add, you attach a new Janus handle to the SIP plugin, and send a <code>register</code> with <code>type:</code> <code>"helper"</code> and providing the same <code>username</code> as the master, plus a <code>master_id</code> attribute referencing the main session;</li>
<li>at this point, the new <code>helper</code> is associated to the <code>master</code> , meaning it can be used to start new calls or receive calls exactly as the main session, and using the same account information, credentials, etc.</li>
</ol>
<p>Notice that, as soon as the <code>master</code> unregisters, or the Janus handle it's on is detached, all the <code>helper</code> sessions associated to it are automatically torn down as well. Specifically, the plugin will forcibly detach the related handles. Should you need to register again, and want some helpers there too, you'll have to add them again.</p>
<p>If you want to see this in practice, the SIP plugin demo has a "hidden" function you can invoke from the JavaScript console to play with helpers: calling the <code>addHelper()</code> function will add a new helper, and show additional controls. You can add as many helpers as you want.</p>
<h1><a class="anchor" id="siptr"></a>
Attended and blind transfers</h1>
<p>The Janus SIP plugin supports both attended and blind transfers, and to do so mostly relies on the multiple calls functionality: as such, make sure you've read and are familiar with the section on <a class="el" href="sip.html#sipmc">Simultaneous SIP calls using the same account</a> .</p>
<p>Most of the transfer-related functionality are based on existing messages and events already documented in the previous section, but there are a few aspects you need to be aware of. First of all, if you're the transferor, you need to use a new request called <code>transfer</code> , that allows you to send a SIP REFER to the transferee so to reach a different target. The <code>transfer</code> request must be formatted like this:</p>
<pre class="fragment">{
        "request" : "transfer",
        "uri" : "&lt;SIP URI to send the transferee too&gt;",
        "replace" : "&lt;call-ID of the call this attended transfer is supposed to replace; default is none, which means blind/unattended transfer&gt;"
}
</pre><p>Whether this is a blind (no call to replace) or attended transfer, a <code>transferring</code> event will be sent back, as this is an asynchronous request. Further updates will come in the form of NOTIFY-related events, as a REFER implicitly creates a subscription.</p>
<p>The recipient of a REFER, instead, will receive an asynchronous event called <code>transfer</code> as well, with info it needs to be aware of. In fact, the SIP plugin doesn't do anything automatically: an incoming REFER is notified to the application, so that it can decide whether to follow up on the transfer or not. The syntax of the event is the following:</p>
<pre class="fragment">{
        "sip" : "event",
        "result" : {
                "event" : "transfer",
                "refer_id" : &lt;unique ID, internal to Janus, of this referral&gt;,
                "refer_to" : "&lt;SIP URI to call&gt;",
                "referred_by" : "&lt;SIP URI SIP URI header conveying the identity of the transferor; optional&gt;",
                "replaces" : "&lt;call-ID of the call this transfer is supposed to replace; optional, and only present for attended transfers&gt;",
                "headers" : "&lt;object with key/value strings; custom headers extracted from SIP event based on incoming_header_prefix defined in register request; optional&gt;"
        }
}
</pre><p>The most important property in that list is <code>refer_id</code> as that value must be included in the <code>call</code> request to call the target, if the transfer is accepted: in fact, that's the only way the SIP plugin has to correlate the new outgoing call to the previous transfer request, and thus be able to notify the transferor about how the call is proceeding by means of NOTIFY events. Notice that, if the transferee decides to follow up on the transfer request, and they're already in a call (e.g., with the transferor), then they must use a different handle for the purpose, e.g., via a helper as described in the <a class="el" href="sip.html#sipmc">Simultaneous SIP calls using the same account</a> section.</p>
<p>The transfer target will receive the call exactly as previously discussed, with the difference that it may or may not include a <code>referred_by</code> property for information purposes. Just as the transferee, if they're already in a call, it's up to the application to create a helper to setup a new Janus handle to accept the transfer.</p>
<p>Notice that the plugin will NOT put the involved calls on-hold, or automatically close calls that are meant to be replaced by a transfer. All this is the application responsibility, and as such it's up to the developer to react to events accordingly. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Thu Apr 24 2025 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2025
</div>
</body>
</html>
